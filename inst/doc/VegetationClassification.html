<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Miquel De Cáceres, CREAF, Barcelona, Spain" />
<meta name="author" content="Susan Wiser, Landcare Research, Lincoln, New Zealand" />

<meta name="date" content="2022-08-24" />

<title>How to use the vegclust package</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">
/* for pandoc --citeproc since 2.11 */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">How to use the vegclust package</h1>
<h4 class="author">Miquel De Cáceres, CREAF, Barcelona, Spain</h4>
<h4 class="author">Susan Wiser, Landcare Research, Lincoln, New
Zealand</h4>
<h4 class="date">2022-08-24</h4>


<div id="TOC">
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a>
<ul>
<li><a href="#what-is-this-tutorial-about" id="toc-what-is-this-tutorial-about">What is this tutorial
about?</a></li>
<li><a href="#example-vegetation-data" id="toc-example-vegetation-data">Example vegetation data</a></li>
</ul></li>
<li><a href="#clustering-methods-in-vegclust" id="toc-clustering-methods-in-vegclust">Clustering methods in
<code>vegclust</code></a>
<ul>
<li><a href="#resemblance-space" id="toc-resemblance-space">Resemblance
space</a></li>
<li><a href="#prototype-based-clustering" id="toc-prototype-based-clustering">Prototype-based clustering</a></li>
<li><a href="#clustering-models" id="toc-clustering-models">Clustering
models</a></li>
<li><a href="#dissimilarity-based-duals" id="toc-dissimilarity-based-duals">Dissimilarity-based duals</a></li>
</ul></li>
<li><a href="#managing-vegetation-classifications" id="toc-managing-vegetation-classifications">Managing vegetation
classifications</a>
<ul>
<li><a href="#creating-classifications-vegclust-and-vegclustdist" id="toc-creating-classifications-vegclust-and-vegclustdist">Creating
classifications: <code>vegclust</code> and
<code>vegclustdist()</code></a></li>
<li><a href="#supervised-classification-as.vegclust-and-vegclass" id="toc-supervised-classification-as.vegclust-and-vegclass">Supervised
classification: <code>as.vegclust()</code> and
<code>vegclass()</code></a></li>
<li><a href="#extending-vegetation-classifications" id="toc-extending-vegetation-classifications">Extending vegetation
classifications</a></li>
</ul></li>
<li><a href="#cluster-characterization" id="toc-cluster-characterization">Cluster characterization</a>
<ul>
<li><a href="#cluster-prototypes-clustcentroid-and-clustmedoid" id="toc-cluster-prototypes-clustcentroid-and-clustmedoid">Cluster
prototypes: <code>clustcentroid()</code> and
<code>clustmedoid()</code></a></li>
<li><a href="#cluster-internal-variability-clustvar" id="toc-cluster-internal-variability-clustvar">Cluster internal
variability: <code>clustvar()</code></a></li>
<li><a href="#distance-between-clusters-interclustdist" id="toc-distance-between-clusters-interclustdist">Distance between
clusters: <code>interclustdist()</code></a></li>
<li><a href="#constancy-classes-clustconst" id="toc-constancy-classes-clustconst">Constancy classes:
<code>clustconst()</code></a></li>
</ul></li>
<li><a href="#bibliography" id="toc-bibliography">Bibliography</a></li>
</ul>
</div>

<div id="introduction" class="section level2">
<h2>Introduction</h2>
<div id="what-is-this-tutorial-about" class="section level3">
<h3>What is this tutorial about?</h3>
<p>Classification of vegetation plot records involves different
activities, including the design of an appropriate vegetation survey,
the use of a classification method to group vegetation observations and
the characterization, validation and naming of the resulting vegetation
groups. In this tutorial we focus on only one of this steps, namely to
group vegetation observations, and we show how to conduct it with the
help of the R package <code>vegclust</code>. Before starting our
examples we need to load the <code>vegclust</code> package and package
<code>vegan</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(vegclust)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(vegan)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Loading required package: permute</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Loading required package: lattice</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; This is vegan 2.6-2</span></span></code></pre></div>
</div>
<div id="example-vegetation-data" class="section level3">
<h3>Example vegetation data</h3>
<p>In order to illustrate the functions in <code>vegclust</code> we will
use a small wetland vegetation data set, consisting of 41 sites and 33
species and published by <span class="citation">Bowman and Wilson
(1986)</span>. The data is included with the <code>vegclust</code>
package:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(wetland)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">dim</span>(wetland)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 41 33</span></span></code></pre></div>
<p>For a number of reasons that we will not detail here, the Euclidean
distance is not an appropriate index to measure the resemblance in
species composition between vegetation plot records. Therefore, we
transform our community data using the chord transformation <span class="citation">(Legendre and Gallagher 2001)</span>, which divides
each value by the norm of the row vector of the corresponding site:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>wetlandchord <span class="ot">=</span> <span class="fu">decostand</span>(wetland,<span class="st">&quot;normalize&quot;</span>)</span></code></pre></div>
<p>Function <code>decostand()</code> is provided within the
<code>vegan</code> package. The Euclidean distance on the transformed
data is equal to the chord distance <span class="citation">(Orlóci
1967)</span> with respect to the raw community data:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>dchord <span class="ot">=</span> <span class="fu">dist</span>(wetlandchord)</span></code></pre></div>
<p>In some of our examples we will use the R objects
<code>wetlandchord</code> or <code>dchord</code> indistinctively,
because package <code>vegclust</code> allows vegetation to be classified
from either a site-by-species data table or from a site-by-site
dissimilarity matrix. In the next section we briefly explain the bases
of the classification methods that are provided in the
<code>vegclust</code> package. We later show how to run those methods
using functions in the package.</p>
</div>
</div>
<div id="clustering-methods-in-vegclust" class="section level2">
<h2>Clustering methods in <code>vegclust</code></h2>
<div id="resemblance-space" class="section level3">
<h3>Resemblance space</h3>
<p>Generally speaking, the goal of clustering is to derive <span class="math inline">\(c\)</span> ‘natural’ classes or clusters from a
set of <span class="math inline">\(n\)</span> unlabelled objects. Those
objects inside a `natural’ cluster show a certain degree of closeness or
similarity and the cluster itself shows a certain degree of isolation
from other clusters. In classification of vegetation the <span class="math inline">\(n\)</span> ‘objects’ to be grouped are samples of
plant communities (i.e. plot records or relevés) and the goal is to
define vegetation types.</p>
<p>When speaking of ‘proximity’ or ‘similarity’, we implicitly assume
there is a procedure to assess the degree of resemblance between the
objects to be grouped. This procedure usually involves describing our
objects using a set of <span class="math inline">\(p\)</span> features
(these are normally species in the case of vegetation) and specifying a
resemblance measure (e.g. distance or dissimilarity). Let <span class="math inline">\(\mathbf{X}=[x_{js}]\)</span> be a site-by-species
data table of dimensions <span class="math inline">\(n\times p\)</span>,
where <span class="math inline">\(x_{js}\)</span> is the abundance of
species <span class="math inline">\(s\)</span> in site <span class="math inline">\(j\)</span>, and let <span class="math inline">\(d\)</span> be an appropriate dissimilarity or
distance measure.</p>
<p>Another way to formalize the resemblance between objects is to
directly provide the similarity or dissimilarity between pairs of
objects in a symmetric resemblance matrix. Let <span class="math inline">\(\mathbf{D}=[d_{ij}]\)</span> be a symmetric
dissimilarity matrix of dimensions <span class="math inline">\(n\times
n\)</span>, where <span class="math inline">\(d_{ij} =
d(\mathbf{x}_i,\mathbf{x}_j)\)</span> is the dissimilarity between
objects <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>. In classification of vegetation <span class="math inline">\(d_{ij} = d(\mathbf{x}_i,\mathbf{x}_j)\)</span> may
represent the compositional dissimilarity between the two plant
communities <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, but it could be based on other
vegetation attributes such as physiognomy.</p>
<p>Regardless of whether we use <span class="math inline">\(\mathbf{X}\)</span> or <span class="math inline">\(\mathbf{D}\)</span>, we will speak here of
<em>resemblance space</em> and our objects (plant communities) will be
formally represented as points in this space. Although we do not cover
this topic in detail here, the reader should be aware that building an
appropriate resemblance space is critical to achieving a vegetation
classification that fits a given purpose. The results of the
classification exercise may be completely different depending on the way
the resemblance space is defined.</p>
</div>
<div id="prototype-based-clustering" class="section level3">
<h3>Prototype-based clustering</h3>
<p><em>Prototype-based</em> clustering methods assume that the
properties of objects in a cluster can be represented using a cluster
<em>prototype</em>, which is formalized as a point in the resemblance
space. The problem is thus to find <span class="math inline">\(c\)</span> prototypes and assign the <span class="math inline">\(n\)</span> objects according to their proximity to
those prototypes, such that the resulting clusters are compact and
isolated one from another.</p>
<p>All the clustering methods discussed here follow an <em>alternate
optimization</em> scheme, meaning that one group of parameters (e.g. the
membership matrix) is optimized by holding the other group (e.g. the
cluster prototypes) fixed and vice versa. Assuming an initial cluster
configuration, this is achieved by iterating the following three
steps:</p>
<ol style="list-style-type: decimal">
<li>Determine the prototype of each cluster <span class="math inline">\(i\)</span>.</li>
<li>Calculate <span class="math inline">\(e_{ij}\)</span>, the distance
from each object <span class="math inline">\(j\)</span> to the prototype
of each cluster <span class="math inline">\(i\)</span>.</li>
<li>Calculate <span class="math inline">\(u_{ij}\)</span>, the (hard or
fuzzy) membership of each object <span class="math inline">\(j\)</span>
to each cluster <span class="math inline">\(i\)</span> (i.e. re-assign
all objects into clusters).</li>
</ol>
<p>Each iteration of the alternate optimization algorithm improves the
<em>objective function</em> of the clustering method. The alternate
optimization algorithm stops when there are no further changes in object
memberships. More technically, it stops if the maximum difference in
object membership values of the last two iterations does not exceed a
user-specified threshold. The starting configuration of clusters is a
critical issue in this kind of classification methods, because the
iterations can result in the alternate optimization algorithm getting
stuck in a suboptimal value of the objective function. For this reason,
several executions of the algorithm are usually tried, each one using a
different starting configuration.</p>
</div>
<div id="clustering-models" class="section level3">
<h3>Clustering models</h3>
<p>There are several prototype-based clustering models in the
<code>vegclust</code> package; all of which follow the iterative
algorithm presented above. The differences between clustering models
arise due to differences in the specific implementation of each step,
resulting from different assumptions of how clusters should be defined.
The clustering models can be divided according to their properties
into:</p>
<ol style="list-style-type: lower-alpha">
<li>Whether object memberships are <strong>fuzzy</strong> or
<strong>hard</strong> (crisp).</li>
<li>Whether cluster prototypes are <strong>centroids</strong> or
<strong>medoids</strong>.</li>
<li>How outlier objects are handled, which gives three kinds of models:
<strong>partitive</strong>, <strong>noise clustering</strong> or
<strong>possibilistic clustering</strong>.</li>
</ol>
<p>In the following subsections we describe the implications of each of
these decisions.</p>
<div id="hard-crisp-or-fuzzy-memberships" class="section level4">
<h4>Hard (crisp) or fuzzy memberships</h4>
<p>With the kind of classification methods described here, it is
costumary to represent the classification of objects into groups using a
<span class="math inline">\(c\times n\)</span> membership matrix, <span class="math inline">\(\mathbf{U}=[u_{ij}]\)</span>, where <span class="math inline">\(u_{ij}\)</span> is the degree of membership of
object <span class="math inline">\(j\)</span> in cluster <span class="math inline">\(i\)</span>. The classification is said to be
<em>hard</em> when the <span class="math inline">\(u_{ij}\)</span>
values are either 0 (object <span class="math inline">\(j\)</span> DOES
NOT belong to cluster <span class="math inline">\(i\)</span>) or 1
(object <span class="math inline">\(j\)</span> DOES belong to cluster
<span class="math inline">\(i\)</span>). In contrast, if the
classification is <em>fuzzy</em> the membership of its objects is
expressed through a degree of membership bounded between 0 (i.e. the
object does not belong to the set at all) and 1 (i.e. the object belongs
completely to the set).</p>
<p>The advantages of using fuzzy set theory in vegetation classification
are that it acknowledges the individualistic concept of species
distribution across gradients of vegetation composition <span class="citation">(Moravec 1989)</span>, and therefore avoids assuming
that vegetation observations (e.g. releves) must be unequivocal
representatives of a type without no admixture of any other types <span class="citation">(Dale 1995)</span>.</p>
</div>
<div id="centroids-or-medoids" class="section level4">
<h4>Centroids or medoids</h4>
<p>The <em>centroid</em> of a cluster <span class="math inline">\(i\)</span> that contains <span class="math inline">\(n_i\)</span> objects is a vector <span class="math inline">\(\mathbf{c}_i\)</span> whose coordinates are the
average, in each dimension <span class="math inline">\(s\)</span>, of
the coordinates of the <span class="math inline">\(n_i\)</span> objects
belonging to the cluster. In vector notation: <span class="math display">\[\begin{equation}\label{eq:centroid}
\mathbf{c}_{i} = \frac{\sum_{j=1}^{n_i}{\mathbf{x}_{j}}}{n_i}
\end{equation}\]</span> The centroid has the property that minimizes the
sum of squared Euclidean distances between itself and each point
belonging to the cluster. Equation~<span class="math inline">\(\ref{eq:centroid}\)</span> can be generalized to
the case of a fuzzy cluster by weighting the coordinates each object by
its degree of membership to the cluster, <span class="math inline">\(u_{ij}\)</span>: <span class="math display">\[\begin{equation}
\mathbf{c}_{i} =
\frac{\sum_{j=1}^n{u_{ij}^m\mathbf{x}_{j}}}{\sum_{j=1}^n{u_{ij}^m}}
\end{equation}\]</span> In the former equation, <span class="math inline">\(m &gt; 0\)</span> is the <em>fuzziness
exponent</em>, which is used to modulate the influence of fuzzy
memberships in the calculation of the centroids. If <span class="math inline">\(m\)</span> is very large only the objects whose
membership is close to 1 will have an influence on the centroid. On the
contrary, if <span class="math inline">\(m\)</span> is small (i.e. close
to 0) then all <span class="math inline">\(n\)</span> objects will
influence the centroid equally and it will approach the overall data
center.</p>
<p>A <em>medoid</em> of a cluster <span class="math inline">\(i\)</span>
that contains <span class="math inline">\(n_i\)</span> objects is
defined as the object, chosen among the <span class="math inline">\(n_i\)</span> objects, for which the sum of
dissimilarities to all the <span class="math inline">\(n_i\)</span>
objects is minimal i.e. it is a most centrally located point in the
cluster. Formally, the medoid is the object <span class="math inline">\(k\)</span> for which: <span class="math display">\[\begin{equation}
\sum_{j=1}^{n_i}{d(\mathbf{x}_k,\mathbf{x}_j)}
\end{equation}\]</span> is minimal. When using fuzzy logic, the medoid
of cluster <span class="math inline">\(i\)</span> is defined as the
object <span class="math inline">\(k\)</span> (among all <span class="math inline">\(n\)</span> objects) that minimizes: <span class="math display">\[\begin{equation}
\sum_{j=1}^n{u_{ij}^md(\mathbf{x}_k,\mathbf{x}_j)}
\end{equation}\]</span> Note that, because the medoid is a point chosen
among the <span class="math inline">\(n\)</span> input objects, we do
not need to calculate its coordinates (although see explanation below
for centroids), moreover, the distance between a medoid and the other
objects (step #2 in the alternate optimization algorithm) will be
readily available from the beginning, so it does not need to be
computed. All this makes dealing with medoids computationally much
faster than dealing with centroids.</p>
</div>
<div id="partitive-clustering" class="section level4">
<h4>Partitive clustering</h4>
<p>A clustering method is called <em>partitive</em> if object
memberships (crisp or fuzzy) are constrained to sum to one for each
object: <span class="math display">\[\begin{equation}\label{eq:partition}
\sum_{i=1}^c{u_{ij}}=1
\end{equation}\]</span> This constrain is usually referred to as the
<em>partition restriction</em>. It ensures that all objects will be
classified as either belonging to a single cluster or dividing their
membership among different clusters. No objects will be left
unclassified.</p>
<p>K-means (KM, also known as hard c-means) <span class="citation">(MacQueen 1967)</span> and Fuzzy c-means (FCM) <span class="citation">(Bezdek 1981)</span> are two, centroid-based, partitive
clustering algorithms widely used in many unsupervised pattern
recognition applications. The main difference between the two methods is
that in KM every object belongs to a single cluster (i.e clusters are
`hard’) whereas in FCM the memberships are fuzzy and a given object may
have some degree of membership to more than one cluster.</p>
<p>Cluster memberships (step #3) are determined in KM simply by
<em>assigning each object to the cluster whose centroid is closest</em>.
In the case of FCM, fuzzy memberships are calculated using the following
formula: <span class="math display">\[\begin{equation}
u_{ij} = \frac{1}{\sum_{l=1}^c{(e_{ij}/e_{lj})^{2/(m-1)}}}
\end{equation}\]</span> As said above, <span class="math inline">\(m&gt;1\)</span> is the fuzziness coefficient. The
smaller the value of <span class="math inline">\(m\)</span>, the closer
to a hard partition will be the result. If <span class="math inline">\(m\)</span> is set too high and the data is noisy
the resulting partition may be completely fuzzy (i.e. where <span class="math inline">\(u_{ij}=1/c\)</span> for all objects and clusters)
and therefore uninformative.</p>
<p>As indicated above, KM and FCM are centroid-based, meaning they use
centroid-based crisp or fuzzy equations, respectively, for step #1. The
corresponding medoid-based methods are Hard C-medoids and Fuzzy
C-medoids, which instead use equations medoid-based crisp and fuzzy
equations, respectively <span class="citation">(Raghu Krishnapuram,
Joshi, and Yi 1999)</span>.</p>
</div>
<div id="noise-clustering" class="section level4">
<h4>Noise clustering</h4>
<p>The noise clustering (NC) method <span class="citation">(R. N. Dave
1991)</span> is an attempt to make the FCM method more robust to the
effect of outliers. The rationale underlying NC is the following: if an
object is an outlier, this means that it lies far from all cluster
prototypes and, therefore, it should have low membership values to all
clusters. In order to achieve these low memberships, the NC considers an
additional class, called <em>Noise</em>. This class is not represented
by a ‘prototype’, like the <span class="math inline">\(c\)</span> ‘true’
clusters. The effect of including the Noise class is that it ‘captures’
objects that are at a distances larger than <span class="math inline">\(\delta\)</span> from all the <span class="math inline">\(c\)</span> ‘true’ prototypes. The NC membership
function (step #3) for the ‘real’ clusters is: <span class="math display">\[\begin{equation}
u_{ij} =
\frac{1}{(e_{ij}/\delta)^{2/(m-1)}+\sum_{l=1}^c{(e_{ij}/e_{lj})^{2/(m-1)}}}
\end{equation}\]</span> whereas the fuzzy membership to the Noise class,
<span class="math inline">\(u_{Nj}\)</span>, is one minus the sum of
memberships to the real clusters. <span class="math display">\[\begin{equation}
u_{Nj} = 1 - \sum_{i=1}^c{u_{ij}}
\end{equation}\]</span> Outlier objects have small membership values to
the <span class="math inline">\(c\)</span> real clusters because the
first term in the denominator of the noise membership equation is large.
The smaller the <span class="math inline">\(\delta\)</span>, the higher
the memberships to the Noise class will be. In contrast, large values of
<span class="math inline">\(\delta\)</span> make NC equivalent to FCM.
In NC, the fuzziness exponent <span class="math inline">\(m\)</span> has
the same interpretation as in FCM. Including the Noise class has the
effect of relaxing the partition restriction. In NC, the partition
restriction is fulfilled when all <span class="math inline">\(c\)</span>
real clusters and the Noise class are considered.</p>
<p>Note that, like FCM and KM, we can define a ‘hard’ counterpart of the
(fuzzy) noise clustering method. Indeed, the hard noise clustering (HNC)
method differs from the fuzzy one in that memberships are not fuzzy.
Like KM, its membership function can be described verbally. One assigns
the object to the noise class if the distances to all cluster centroids
is larger than <span class="math inline">\(\delta\)</span>. Otherwise,
one assigns the object to the cluster whose centroid is closest, as in
KM.</p>
<p>The noise clustering method was originally defined with centroids as
prototypes. However, either hard or fuzzy noise clustering can be
applied to medoids instead of centroids. Although we have found no
references exploring this approach, the corresponding algorithms could
be named ‘hard noise clustering with medoids’ (HNCdd) and ‘(fuzzy) noise
clustering with medoids’ (NCdd).</p>
</div>
<div id="possibilistic-clustering" class="section level4">
<h4>Possibilistic clustering</h4>
<p>Possibilistic C-means <span class="citation">(R. Krishnapuram and
Keller 1993, 1996)</span> is another modification of FCM seeking
increased cluster robustness. The partition restriction is eliminated in
PCM, which produces <span class="math inline">\(c\)</span> independent
fuzzy clusters, each corresponding to a dense region of points. Whereas
the FCM and NC membership functions compare the distance from the object
to the cluster of interest, <span class="math inline">\(e_{ij}\)</span>,
with the distances to the remaining prototypes (and to the noise class
in the case of NC), in PCM the membership value for a given object to a
cluster does not depend on the distances to the remaining cluster
prototypes. Instead, the distance to the cluster of interest is compared
to a reference distance (<span class="math inline">\(\eta_i\)</span>):
<span class="math display">\[\begin{equation}
u_{ij} = \frac{1}{1+(e^2_{ij}/\eta_i)^{1/(m-1)}}
\end{equation}\]</span> The reference distance is a parameter that must
be provided for each cluster. All objects whose distance to the cluster
center is smaller than <span class="math inline">\(\eta_i\)</span> will
obtain a membership value higher than 0.5.</p>
<p>The fact that the membership to a given cluster does not depend on
the distances to the remaining cluster prototypes entails that cluster
repulsion is eliminated in PCM, with the consequence that samples can
have high membership to different clusters. Good estimation of <span class="math inline">\(\eta_i\)</span> is crucial for the success of the
PCM method <span class="citation">(De Cáceres, Oliva, and Font
2006)</span>. Inadequate initialization of <span class="math inline">\(\eta_i\)</span> can lead to a loss of cluster
structures, even with the correct partition as initial starting
configuration. A single PCM run can be regarded as <span class="math inline">\(c\)</span> independent runs of NC, each looking
for a single cluster and where <span class="math inline">\(\delta_i^2=\eta_i\)</span> <span class="citation">(R. N. Dave and Krishnapuram 1997)</span>. In
vegetation data plant communities with intermediate characteristics are
frequent. This fact makes the PCM method impractical for classification
of vegetation, because without cluster repulsion PCM clusters are
frequently highly mobile and converge to the same cluster, leaving large
parts of the data unassigned <span class="citation">(De Cáceres, Font,
and Oliva 2010)</span>.</p>
</div>
</div>
<div id="dissimilarity-based-duals" class="section level3">
<h3>Dissimilarity-based duals</h3>
<p>All the clustering methods presented above can be executed on a
resemblance space described using either <span class="math inline">\(\mathbf{X}\)</span> or <span class="math inline">\(\mathbf{D}\)</span>. The latter case avoids
explicitly dealing with coordinates when creating groups.</p>
<div id="medoid-based-clustering-and-dissimilarity-matrices" class="section level4">
<h4>Medoid-based clustering and dissimilarity matrices</h4>
<p>Because medoids are selected among the objects to be classified it is
obvious that the distance to the cluster prototypes, <span class="math inline">\(e_{ij}\)</span>, can be drawn from a symmetric
matrix of pairwise distances between objects calculated before the
alternate optimization algorithm is initiated. In other words, one can
conduct medoid-based clustering on a site-by-site distance matrix
instead of using a site-by-species rectangular matrix. Moreover, one can
straightforwardly skip the use of Euclidean distance and use a
dissimilarity measure more appropriate for ecological data.</p>
</div>
<div id="centroid-based-clustering-and-dissimilarity-matrices" class="section level4">
<h4>Centroid-based clustering and dissimilarity matrices</h4>
<p>When dealing with centroids, it may seem unavoidable to calculate
centroid coordinates (step S.1) before calculating the (squared)
Euclidean distances to cluster centers <span class="math inline">\(e_{ij}\)</span> (step S.2): <span class="math display">\[\begin{equation}
e_{ij}^2 = \| \mathbf{c}_i-\mathbf{x}_j \|^2
\end{equation}\]</span> However, there is a mathematical trick that
avoids the need to calculate the coordinates <span class="math inline">\(\mathbf{c}_i\)</span> explictly. Let <span class="math inline">\(\mathbf{D}\)</span> be the matrix of Euclidean
distances between pairs of objects. We can obtain <span class="math inline">\(e_{ij}^2\)</span> as follows: <span class="math display">\[\begin{equation}
e_{ij}^2 = \frac{1}{n_i}\sum_{l=1}^{n_i}{d_{lj}^2}-
\frac{1}{2n_i^2}\sum_{k=1}^{n_i}\sum_{l=1}^{n_i}{d_{lk}^2}
\end{equation}\]</span> The left part of this equation is a sum of
squared distances from the target object to all the other objects in the
cluster. The right part of the equation is an average of squared
distances between objects in the cluster. Distance-based <span class="math inline">\(e_{ij}^2\)</span> equation can be generalized to
the case of a fuzzy cluster:</p>
<p><span class="math display">\[\begin{equation}
e_{ij}^2 = \frac{1}{\sum_{k=1}^n{u_{ik}^m}}\sum_{l=1}^{n_i}{d_{lj}^2}-
\frac{1}{2\left(\sum_{k=1}^n{u_{ik}^m}\right)^2}\sum_{k=1}^{n}\sum_{l=1}^{n}{u_{ik}^mu_{il}^md_{lk}^2}
\end{equation}\]</span> Crisp and fuzzy distance-based equations allow
the Euclidean distance to a centroid to be determined without
calculating its coordinates. Therefore, they allow steps #1 and #2 to be
combined into a single step. In other words, distance-based duals exist
for centroid-based clustering methods when the resemblance space
comprises Euclidean distances <span class="citation">(R. J. Hathaway,
Davenport, and Bezdek 1989; R. Hathaway, Bezdek, and Davenport
1996)</span>.</p>
<p>If we transform the original data in order to emulate a distance
(like the chord), then the duality holds, although centroids are defined
in the transformed space. What happens if the values in <span class="math inline">\(\mathbf{D}\)</span> were not calculated using the
Euclidean distance? Crisp and fuzzy distance-based equations are also
valid for other dissimilarity measures, although there are important
details to be remembered. These equations assume that the resemblance
space is Euclidean (i.e. does not produce negative eigenvalues in
principal coordinates analysis) and that centroids are appropriate
prototypes for clusters. If the dissimilarities do not have the
Euclidean property some oddities may arise <span class="citation">(R. J.
Hathaway and Bezdek 1994)</span>. For example, it is possible to obtain
negative <span class="math inline">\(e_{ij}^2\)</span> values, specially
for groups of small size. In practice, however, when these negative
distances occur they can be reset to zero <span class="citation">(De
Cáceres, Oliva, and Font 2006)</span>.</p>
</div>
</div>
</div>
<div id="managing-vegetation-classifications" class="section level2">
<h2>Managing vegetation classifications</h2>
<div id="creating-classifications-vegclust-and-vegclustdist" class="section level3">
<h3>Creating classifications: <code>vegclust</code> and
<code>vegclustdist()</code></h3>
<p>Functions <code>vegclust</code> and <code>vegclustdist()</code> allow
vegetation types to be defined from a set of unlabelled vegetation
observations (i.e. relevés or plot records) using any of the clustering
models explained in the previous section. <code>vegclust</code> requires
a rectangular site-by-species matrix, whereas
<code>vegclustdist()</code> requires a symmetric site-by-site
dissimilarity matrix.</p>
<div id="the-k-means-model" class="section level4">
<h4>The K-means model</h4>
<p>The following piece of code produces a classification of our example
data set into three groups using the K-means clustering model:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>wetland.km <span class="ot">=</span> <span class="fu">vegclust</span>(<span class="at">x =</span> wetlandchord, <span class="at">mobileCenters=</span><span class="dv">3</span>, </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">method=</span><span class="st">&quot;KM&quot;</span>, <span class="at">nstart=</span><span class="dv">20</span>)</span></code></pre></div>
<p>The result is an object of class <code>vegclust</code>, in fact a
list with several components (method, parameters, prototypes, objective
function, etc.):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(wetland.km)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  [1] &quot;mode&quot;          &quot;method&quot;        &quot;m&quot;             &quot;dnoise&quot;       </span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  [5] &quot;eta&quot;           &quot;memb&quot;          &quot;mobileCenters&quot; &quot;fixedCenters&quot; </span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  [9] &quot;dist2clusters&quot; &quot;withinss&quot;      &quot;size&quot;          &quot;functional&quot;   </span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [13] &quot;iter&quot;</span></span></code></pre></div>
<p>One of the most important components is the membership matrix <span class="math inline">\(\mathbf{U}\)</span>, which we show transposed
here:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">t</span>(wetland.km<span class="sc">$</span>memb)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    5 8 13 4 17 3 9 21 16 14 2 15 1 7 10 40 23 25 22 20 6 18 12 39 19 11 30 34</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1 1 1  1 1  1 1 1  1  1  1 1  1 1 1  1  0  0  0  0  0 0  0  0  0  0  0  0  0</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2 0 0  0 0  0 0 0  0  0  0 0  0 0 0  0  1  1  1  1  1 1  1  1  1  1  1  0  0</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3 0 0  0 0  0 0 0  0  0  0 0  0 0 0  0  0  0  0  0  0 0  0  0  0  0  0  1  1</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    28 31 26 29 33 24 36 37 41 27 32 35 38</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1  0  0  0  0  0  0  0  0  0  0  0  1  1</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2  0  0  1  1  1  0  0  0  0  0  0  0  0</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3  1  1  0  0  0  1  1  1  1  1  1  0  0</span></span></code></pre></div>
<p>Another important component is the matrix containing the coordinates
of cluster centroids (i.e. vectors <span class="math inline">\(\mathbf{c}_i\)</span> for each cluster):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(wetland.km<span class="sc">$</span>mobileCenters, <span class="at">dig=</span><span class="dv">3</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Abefic Merhed Alyvag Pancam Abemos Melcor Ludoct Eupvac Echpas Passcr Poa2</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1  0.000  0.000  0.000  0.027  0.000  0.062  0.000  0.039  0.048  0.000 0.00</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2  0.000  0.000  0.047  0.076  0.016  0.153  0.000  0.050  0.066  0.000 0.01</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3  0.018  0.068  0.000  0.356  0.015  0.275  0.019  0.205  0.102  0.026 0.00</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Carhal Dendio Casobt Aesind Cyprot Ipocop Cynarc Walind Sessp. Phynod Echell</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1  0.037  0.016  0.016  0.000  0.000  0.000  0.000  0.068  0.144  0.000  0.049</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2  0.069  0.000  0.000  0.075  0.081  0.013  0.013  0.064  0.104  0.715  0.119</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3  0.000  0.000  0.000  0.019  0.176  0.040  0.432  0.078  0.157  0.064  0.112</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Helind Ipoaqu Orysp. Elesp. Psespi Ludads Polatt  Poa1 Helcri Physp. Goopur</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1  0.125  0.055  0.649  0.154  0.192  0.204  0.097 0.000  0.000  0.012  0.012</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2  0.172  0.048  0.172  0.138  0.027  0.000  0.000 0.013  0.013  0.000  0.000</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3  0.019  0.037  0.040  0.000  0.000  0.000  0.000 0.000  0.000  0.000  0.000</span></span></code></pre></div>
<p>The same classification exercise can be conducted from the matrix of
chord distances between objects if we use function
<code>vegclustdist()</code> instead of <code>vegclust</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>wetland.kmdist <span class="ot">=</span> <span class="fu">vegclustdist</span>(<span class="at">x =</span> dchord, <span class="at">mobileMemb=</span><span class="dv">3</span>, </span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>                              <span class="at">method=</span><span class="st">&quot;KM&quot;</span>, <span class="at">nstart =</span> <span class="dv">20</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(wetland.kmdist)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  [1] &quot;mode&quot;          &quot;method&quot;        &quot;m&quot;             &quot;dnoise&quot;       </span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  [5] &quot;eta&quot;           &quot;memb&quot;          &quot;mobileCenters&quot; &quot;fixedCenters&quot; </span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  [9] &quot;dist2clusters&quot; &quot;withinss&quot;      &quot;size&quot;          &quot;functional&quot;</span></span></code></pre></div>
<p>Note the different way to specify the number of clusters. In the case
of <code>vegclustdist()</code> we do not obtain cluster centroids,
because they cannot be calculated explicitly:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>wetland.kmdist<span class="sc">$</span>mobileCenters</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; NULL</span></span></code></pre></div>
<p>But we do obtain cluster memberships:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">t</span>(wetland.kmdist<span class="sc">$</span>memb)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    5 8 13 4 17 3 9 21 16 14 2 15 1 7 10 40 23 25 22 20 6 18 12 39 19 11 30 34</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1 0 0  0 0  0 0 0  0  0  0 0  0 0 0  0  0  0  0  0  0 0  0  0  0  0  0  1  1</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2 0 0  0 0  0 0 0  0  0  0 0  0 0 0  0  1  1  1  1  1 1  1  1  1  1  1  0  0</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3 1 1  1 1  1 1 1  1  1  1 1  1 1 1  1  0  0  0  0  0 0  0  0  0  0  0  0  0</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    28 31 26 29 33 24 36 37 41 27 32 35 38</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1  1  1  0  0  0  1  1  1  1  1  1  0  0</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2  0  0  1  1  1  0  0  0  0  0  0  0  0</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3  0  0  0  0  0  0  0  0  0  0  0  1  1</span></span></code></pre></div>
<p>Because we used the same resemblance space (although in different
form) in our examples, both <code>vegclust</code> and
<code>vegclustdist()</code> should give the same result provided the
algorithm has not become stuck in a relative optimum of the objective
function. Although both R functions return objects of class
<code>vegclust</code>, we can identify whether calculations were done
from dissimilarities or from rectangular matrices by inspecting the
‘mode’ element of the list:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>wetland.km<span class="sc">$</span>mode</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;raw&quot;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>wetland.kmdist<span class="sc">$</span>mode</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;dist&quot;</span></span></code></pre></div>
<p>In the following subsections we run <code>vegclust</code> using other
clustering models, but the same examples could be made using
<code>vegclustdist()</code>.</p>
</div>
<div id="the-fuzzy-c-means-model" class="section level4">
<h4>The Fuzzy C-means model</h4>
<p>Let us inspect the distance of each object to each cluster
centroid:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(<span class="fu">t</span>(wetland.km<span class="sc">$</span>dist2clusters), <span class="at">dig=</span><span class="dv">2</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;       5    8   13    4   17    3    9   21   16   14    2   15    1    7   10</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1 0.54 0.68 0.44 0.45 0.64 0.76 0.95 0.50 0.64 0.46 0.38 0.57 0.47 0.72 0.87</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2 1.05 1.10 1.09 1.14 1.11 1.22 1.23 1.09 1.09 1.10 1.12 1.19 1.12 1.15 1.19</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3 1.12 1.12 1.14 1.17 1.07 1.22 1.22 1.20 1.17 1.16 1.17 1.21 1.21 1.18 1.23</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      40   23   25   22   20    6   18   12   39   19   11   30   34   28   31</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1 1.11 0.92 0.86 0.73 1.11 1.15 1.19 1.16 1.12 0.97 1.13 1.20 1.22 1.19 1.20</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2 0.40 0.60 0.51 0.67 0.56 0.47 0.45 0.40 0.52 0.44 0.64 1.16 1.20 1.15 1.19</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3 1.09 1.07 1.12 1.03 1.15 1.06 1.12 1.12 1.06 1.07 1.07 0.86 0.66 0.77 0.69</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      26   29   33   24   36   37   41   27   32   35   38</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1 1.22 1.17 1.22 1.20 1.18 1.17 0.99 1.22 1.17 0.80 0.68</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2 0.81 0.78 0.49 1.04 0.90 1.15 1.14 1.19 1.13 1.03 1.10</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3 1.00 0.92 1.00 0.55 0.62 0.55 0.56 0.78 0.73 0.95 0.99</span></span></code></pre></div>
<p>For many objects the distance to the cluster where they have been
assigned is much smaller than the distance to other clusters. However,
for some objects (such as ‘22’, ‘29’ or ‘35’) the distance to the
closest cluster center does not differ much from the distance to second
closest one. Are those latter objects well assigned? Should these
objects have intermediate degrees of membership instead of picking one
cluster arbitrarily? The Fuzzy C-means cluster model allows fuzzy
memberships to be obtained as an alternative to crisp memberships:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>wetland.fcm <span class="ot">=</span> <span class="fu">vegclust</span>(<span class="at">x =</span> wetlandchord, <span class="at">mobileCenters=</span><span class="dv">3</span>, </span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>                       <span class="at">method=</span><span class="st">&quot;FCM&quot;</span>, <span class="at">m=</span><span class="fl">1.2</span>, <span class="at">nstart=</span><span class="dv">20</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(<span class="fu">t</span>(wetland.fcm<span class="sc">$</span>memb), <span class="at">dig=</span><span class="dv">3</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;        5     8 13 4    17     3     9 21    16 14 2    15 1     7    10 40</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1 0.001 0.007  0 0 0.004 0.009 0.070  0 0.004  0 0 0.001 0 0.011 0.044  1</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2 0.001 0.007  0 0 0.007 0.011 0.086  0 0.003  0 0 0.001 0 0.009 0.036  0</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3 0.998 0.985  1 1 0.990 0.981 0.844  1 0.993  1 1 0.999 1 0.981 0.920  0</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;       23    25    22    20 6 18 12    39 19    11    30    34    28    31    26</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1 0.980 0.992 0.581 0.998 1  1  1 0.999  1 0.992 0.040 0.002 0.016 0.003 0.841</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2 0.004 0.001 0.014 0.001 0  0  0 0.001  0 0.005 0.928 0.996 0.971 0.993 0.141</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3 0.016 0.007 0.405 0.001 0  0  0 0.000  0 0.003 0.031 0.002 0.013 0.003 0.017</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;       29    33    24    36    37    41    27    32    35    38</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1 0.742 0.999 0.002 0.020 0.001 0.001 0.015 0.011 0.057 0.006</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2 0.241 0.001 0.998 0.978 0.999 0.995 0.973 0.980 0.160 0.024</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3 0.017 0.000 0.000 0.001 0.001 0.004 0.012 0.008 0.783 0.970</span></span></code></pre></div>
<p>A comparison of these memberships with the distance to the clusters
shown before will reveal that intermediate objects obtain fuzzier
membership values than other objects.</p>
<p>Although FCM is theoretically a better model than KM for vegetation
classification, vegetation scientists are normally interested in crisp
assignments. The function <code>defuzzify()</code> allows fuzzy
membership matrix to be converted into a crisp one:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>groups <span class="ot">=</span> <span class="fu">defuzzify</span>(wetland.fcm)<span class="sc">$</span>cluster</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>groups</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    5    8   13    4   17    3    9   21   16   14    2   15    1    7   10   40 </span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M1&quot; </span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   23   25   22   20    6   18   12   39   19   11   30   34   28   31   26   29 </span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M1&quot; &quot;M1&quot; </span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   33   24   36   37   41   27   32   35   38 </span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;M1&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M3&quot; &quot;M3&quot;</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(groups)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; groups</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1 M2 M3 </span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 14 10 17</span></span></code></pre></div>
<p>Another way of defuzzifying the membership matrix is by setting a
threshold of minimum fuzzy membership:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>groups <span class="ot">=</span> <span class="fu">defuzzify</span>(wetland.fcm, <span class="at">method =</span> <span class="st">&quot;cut&quot;</span>, <span class="at">alpha =</span> <span class="fl">0.8</span>)<span class="sc">$</span>cluster</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>groups</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    5    8   13    4   17    3    9   21   16   14    2   15    1    7   10   40 </span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M1&quot; </span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   23   25   22   20    6   18   12   39   19   11   30   34   28   31   26   29 </span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;M1&quot; &quot;M1&quot;   NA &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M1&quot;   NA </span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   33   24   36   37   41   27   32   35   38 </span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;M1&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot;   NA &quot;M3&quot;</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(groups, <span class="at">useNA =</span> <span class="st">&quot;always&quot;</span>)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; groups</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   M1   M2   M3 &lt;NA&gt; </span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   12   10   16    3</span></span></code></pre></div>
<p>With this second defuzzification approach intermediate objects remain
unclassified (indicated as missing values). It is important to recognise
that FCM fuzzy membership values depend on the fuzziness exponent <span class="math inline">\(m\)</span>. In fact, if we run FCM with a very
large <span class="math inline">\(m\)</span> value we will obtain
uninformative results:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>wetland.fcm2 <span class="ot">=</span> <span class="fu">vegclust</span>(<span class="at">x =</span> wetlandchord, <span class="at">mobileCenters=</span><span class="dv">3</span>, </span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>                       <span class="at">method=</span><span class="st">&quot;FCM&quot;</span>, <span class="at">m=</span><span class="dv">10</span>, <span class="at">nstart=</span><span class="dv">20</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(<span class="fu">t</span>(wetland.fcm2<span class="sc">$</span>memb), <span class="at">dig=</span><span class="dv">3</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;        5     8    13     4    17     3     9    21    16    14     2    15</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2 0.334 0.334 0.334 0.334 0.334 0.334 0.333 0.334 0.334 0.334 0.334 0.334</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;        1     7    10    40    23    25    22    20     6    18    12    39</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1 0.333 0.333 0.333 0.334 0.334 0.334 0.333 0.334 0.334 0.334 0.334 0.334</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2 0.334 0.334 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;       19    11    30    34    28    31    26    29    33    24    36    37</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1 0.334 0.334 0.333 0.333 0.333 0.333 0.334 0.334 0.334 0.333 0.334 0.333</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;       41    27    32    35    38</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1 0.333 0.333 0.333 0.333 0.333</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2 0.334 0.333 0.333 0.334 0.334</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3 0.333 0.333 0.333 0.333 0.333</span></span></code></pre></div>
<p>These uninformative results become obvious after defuzzification of
the membership matrix:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>groups2 <span class="ot">=</span> <span class="fu">defuzzify</span>(wetland.fcm2, <span class="at">method =</span> <span class="st">&quot;cut&quot;</span>, <span class="at">alpha =</span> <span class="fl">0.8</span>)<span class="sc">$</span>cluster</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(groups2, <span class="at">useNA =</span> <span class="st">&quot;always&quot;</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; groups2</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &lt;NA&gt; </span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   41</span></span></code></pre></div>
</div>
<div id="the-noise-clustering-model" class="section level4">
<h4>The Noise clustering model</h4>
<p>In the previous two models, all objects were assigned, either
completely to one cluster or with their membership divided among
clusters (in other words, we accepted the partition restriction). This
may be appropriate in many instances, but it may cause problems if some
of the plant communities sampled include rare species assemblages. These
plant communities would more appropriately be classified as ‘outliers’
and should not influence the cluster prototypes. In the noise clustering
(NC) model we allow outlier objects to be excluded from the
classification:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>wetland.nc <span class="ot">=</span> <span class="fu">vegclust</span>(<span class="at">x =</span> wetlandchord, <span class="at">mobileCenters=</span><span class="dv">3</span>,</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>                       <span class="at">method=</span><span class="st">&quot;NC&quot;</span>, <span class="at">m=</span><span class="fl">1.2</span>, <span class="at">dnoise=</span><span class="fl">0.8</span>, <span class="at">nstart=</span><span class="dv">20</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(<span class="fu">t</span>(wetland.nc<span class="sc">$</span>memb), <span class="at">dig=</span><span class="dv">2</span>)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;       5    8 13 4   17    3    9 21   16   14 2   15 1    7   10 40   23   25</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1 0.00 0.00  0 0 0.00 0.01 0.01  0 0.00 0.00 0 0.00 0 0.01 0.01  1 0.93 0.98</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2 0.99 0.85  1 1 0.93 0.41 0.08  1 0.86 0.99 1 0.93 1 0.49 0.12  0 0.01 0.01</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3 0.00 0.00  0 0 0.00 0.01 0.01  0 0.00 0.00 0 0.00 0 0.01 0.01  0 0.00 0.00</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; N  0.01 0.14  0 0 0.07 0.58 0.90  0 0.13 0.01 0 0.07 0 0.49 0.86  0 0.06 0.01</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      22   20 6 18 12   39 19   11   30   34   28   31   26   29   33 24 36 37</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1 0.39 0.98 1  1  1 0.99  1 0.93 0.01 0.00 0.02 0.00 0.28 0.34 0.99  0  0  0</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2 0.50 0.00 0  0  0 0.00  0 0.00 0.01 0.00 0.01 0.00 0.01 0.01 0.00  0  0  0</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3 0.00 0.00 0  0  0 0.00  0 0.00 0.07 0.98 0.08 0.98 0.03 0.08 0.00  1  1  1</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; N  0.11 0.02 0  0  0 0.01  0 0.06 0.90 0.02 0.89 0.02 0.68 0.58 0.01  0  0  0</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      41   27   32   35   38</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1 0.00 0.01 0.02 0.03 0.00</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2 0.01 0.01 0.01 0.48 0.90</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3 0.93 0.05 0.11 0.02 0.00</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; N  0.06 0.92 0.85 0.47 0.09</span></span></code></pre></div>
<p>As with FCM, some objects have intermediate memberships. In addition,
there are some objects with high membership to the Noise class, which
indicates that they are distant from all ‘true’ cluster centers. These
objects can be considered ‘outliers’ and remain unclassified:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>groups <span class="ot">=</span> <span class="fu">defuzzify</span>(wetland.nc)<span class="sc">$</span>cluster</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>groups</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    5    8   13    4   17    3    9   21   16   14    2   15    1    7   10   40 </span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot;  &quot;N&quot;  &quot;N&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot;  &quot;N&quot;  &quot;N&quot; &quot;M1&quot; </span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   23   25   22   20    6   18   12   39   19   11   30   34   28   31   26   29 </span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;M1&quot; &quot;M1&quot; &quot;M2&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot;  &quot;N&quot; &quot;M3&quot;  &quot;N&quot; &quot;M3&quot;  &quot;N&quot;  &quot;N&quot; </span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   33   24   36   37   41   27   32   35   38 </span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;M1&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot;  &quot;N&quot;  &quot;N&quot; &quot;M2&quot; &quot;M2&quot;</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(groups)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; groups</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1 M2 M3  N </span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 11 14  6 10</span></span></code></pre></div>
<p>Note that we can defuzzify the membership matrix using a threshold,
as before, and identify both intermediates (‘NA’) and outliers (members
of the noise class: `N’):</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>groups <span class="ot">=</span> <span class="fu">defuzzify</span>(wetland.nc, <span class="at">method=</span><span class="st">&quot;cut&quot;</span>, <span class="at">alpha=</span><span class="fl">0.8</span>)<span class="sc">$</span>cluster</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>groups</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    5    8   13    4   17    3    9   21   16   14    2   15    1    7   10   40 </span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot;   NA  &quot;N&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot; &quot;M2&quot;   NA  &quot;N&quot; &quot;M1&quot; </span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   23   25   22   20    6   18   12   39   19   11   30   34   28   31   26   29 </span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;M1&quot; &quot;M1&quot;   NA &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot;  &quot;N&quot; &quot;M3&quot;  &quot;N&quot; &quot;M3&quot;   NA   NA </span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   33   24   36   37   41   27   32   35   38 </span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;M1&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot; &quot;M3&quot;  &quot;N&quot;  &quot;N&quot;   NA &quot;M2&quot;</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(groups, <span class="at">useNA =</span> <span class="st">&quot;always&quot;</span>)</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; groups</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   M1   M2   M3    N &lt;NA&gt; </span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   11   12    6    6    6</span></span></code></pre></div>
<p>In vegetation classification, distinguishing between an intermediate
or an outlier will not always be clearcut. Nevertheless, the distinction
may be useful in practice because outlier objects may relate to
vegetation patterns that exist in the study area but happen to be
underrepresented in the sample. That is, outlier plant communities may
be rare for the given vegetation data set only, in the sense that if new
data were added they would belong to a vegetation type. Alternatively,
they may represent rare species assemblages for the study area.
Distinguishing between one case or the other cannot be done without
collecting more data <span class="citation">(Wiser and De Cáceres
2012)</span>.</p>
<p>An advantage of the NC model over FCM or KM is that ‘outliers’ do not
influence the cluster centers. As a result, the cluster centers are more
separated from each other than in the previous models. Compare the
following distance matrices between cluster centroids:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dist</span>(wetland.km<span class="sc">$</span>mobileCenters)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;           M1        M2</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2 0.9248370          </span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3 0.9567205 0.8997438</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="fu">dist</span>(wetland.fcm<span class="sc">$</span>mobileCenters)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;           M1        M2</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2 0.8852470          </span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3 0.9280591 0.9387319</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="fu">dist</span>(wetland.nc<span class="sc">$</span>mobileCenters)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;           M1        M2</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2 0.9735403          </span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3 1.0102668 1.0666511</span></span></code></pre></div>
<p>However, this particular advantage can also be obtained (in partitive
methods) if medoids are used as prototypes instead of centroids (see
below).</p>
</div>
<div id="medoid-based-clustering" class="section level4">
<h4>Medoid-based clustering</h4>
<p>All the examples that we have shown so far could be repeated using
medoids as cluster prototypes instead of centroids. For example, with
the K-medoids (the K-means analogue) would be:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>wetland.kmdd <span class="ot">=</span> <span class="fu">vegclust</span>(<span class="at">x =</span> wetlandchord, <span class="at">mobileCenters=</span><span class="dv">3</span>, </span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">method=</span><span class="st">&quot;KMdd&quot;</span>, <span class="at">nstart=</span><span class="dv">20</span>)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="fu">t</span>(wetland.kmdd<span class="sc">$</span>memb)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    5 8 13 4 17 3 9 21 16 14 2 15 1 7 10 40 23 25 22 20 6 18 12 39 19 11 30 34</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1 1 1  1 1  1 1 1  1  1  1 1  1 1 1  1  0  0  0  1  0 0  0  0  0  0  0  0  0</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2 0 0  0 0  0 0 0  0  0  0 0  0 0 0  0  1  1  1  0  1 1  1  1  1  1  1  0  0</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3 0 0  0 0  0 0 0  0  0  0 0  0 0 0  0  0  0  0  0  0 0  0  0  0  0  0  1  1</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    28 31 26 29 33 24 36 37 41 27 32 35 38</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1  0  0  0  0  0  0  0  0  0  0  0  1  1</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2  0  0  1  1  1  0  0  0  0  0  0  0  0</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3  1  1  0  0  0  1  1  1  1  1  1  0  0</span></span></code></pre></div>
<p>When ran using a site-by-species matrix as input,
<code>vegclust()</code> returns the coordinates of medoids as the
cluster centers:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(wetland.kmdd<span class="sc">$</span>mobileCenters, <span class="at">dig=</span><span class="dv">3</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Abefic Merhed Alyvag Pancam Abemos Melcor Ludoct Eupvac Echpas Passcr Poa2</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1      0      0      0  0.000      0  0.183      0  0.000      0  0.000    0</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2      0      0      0  0.000      0  0.177      0  0.000      0  0.000    0</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3      0      0      0  0.258      0  0.258      0  0.258      0  0.258    0</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Carhal Dendio Casobt Aesind Cyprot Ipocop Cynarc Walind Sessp. Phynod Echell</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1  0.000      0      0      0      0      0  0.000      0  0.000  0.000  0.000</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2  0.177      0      0      0      0      0  0.000      0  0.000  0.884  0.177</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3  0.000      0      0      0      0      0  0.775      0  0.258  0.258  0.000</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Helind Ipoaqu Orysp. Elesp. Psespi Ludads Polatt Poa1 Helcri Physp. Goopur</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M1  0.000  0.000  0.913  0.183  0.183  0.183  0.183    0      0      0      0</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M2  0.177  0.177  0.000  0.177  0.177  0.000  0.000    0      0      0      0</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; M3  0.000  0.000  0.000  0.000  0.000  0.000  0.000    0      0      0      0</span></span></code></pre></div>
<p>However, when using site-by-site dissimilarity matrices as input for
<code>vegclustdist()</code>, the indices of objects are returned
instead:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>wetland.kmdd <span class="ot">=</span> <span class="fu">vegclustdist</span>(<span class="at">x =</span> dchord, <span class="at">mobileMemb=</span><span class="dv">3</span>, </span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">method=</span><span class="st">&quot;KMdd&quot;</span>, <span class="at">nstart=</span><span class="dv">20</span>)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>wetland.kmdd<span class="sc">$</span>mobileCenters</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 11 23 34</span></span></code></pre></div>
</div>
</div>
<div id="supervised-classification-as.vegclust-and-vegclass" class="section level3">
<h3>Supervised classification: <code>as.vegclust()</code> and
<code>vegclass()</code></h3>
<p>Vegetation types are meant to be used. For example, a new area may be
surveyed and a map of vegetation types may be needed. Here we simulate
the process of assigning new observations to a vegetation classification
created <em>a priori</em>. In order to simulate this two-step process,
we split our example data set into two matrices, one with the 31 objects
whose group classification will be known <em>a priori</em> and the other
with the 10 objects whose classification is to be studied:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>wetland<span class="fl">.31</span> <span class="ot">=</span> wetlandchord[<span class="dv">1</span><span class="sc">:</span><span class="dv">31</span>,]</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>wetland<span class="fl">.31</span> <span class="ot">=</span> wetland<span class="fl">.31</span>[,<span class="fu">colSums</span>(wetland<span class="fl">.31</span>)<span class="sc">&gt;</span><span class="dv">0</span>]</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="fu">dim</span>(wetland<span class="fl">.31</span>)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 31 27</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>wetland<span class="fl">.10</span> <span class="ot">=</span> wetlandchord[<span class="sc">-</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">31</span>),]</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>wetland<span class="fl">.10</span> <span class="ot">=</span> wetland<span class="fl">.10</span>[,<span class="fu">colSums</span>(wetland<span class="fl">.10</span>)<span class="sc">&gt;</span><span class="dv">0</span>] </span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="fu">dim</span>(wetland<span class="fl">.10</span>)</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 10 22</span></span></code></pre></div>
<p>As initial classification, we simply take the two groups resulting
from a K-means analysis (using function <code>kmeans()</code> from the
<code>stats</code> package) on the first data set:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>km <span class="ot">=</span> <span class="fu">kmeans</span>(wetland<span class="fl">.31</span>, <span class="dv">2</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>groups <span class="ot">=</span> km<span class="sc">$</span>cluster</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>groups</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  5  8 13  4 17  3  9 21 16 14  2 15  1  7 10 40 23 25 22 20  6 18 12 39 19 11 </span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  2  2  2  2  2  2  2  2  2  2  2 </span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 30 34 28 31 26 </span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  1  1  1  1  2</span></span></code></pre></div>
<p>The idea is to know whether the ten objects of the second data set
may be assigned to the vegetation types defined using the first data
set. Because our initial classification was not obtained using function
<code>vegclust()</code>, we need to transform the input classification
of 31 objects into an object of class <code>vegclust</code>. This is
done using function <code>as.vegclust()</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>wetland.<span class="fl">31.</span>km <span class="ot">=</span> <span class="fu">as.vegclust</span>(wetland<span class="fl">.31</span>, groups)</span></code></pre></div>
<p>Note that we did not specify the clustering model for our
<code>vegclust</code> object. By default, the clustering method is
K-means (KM):</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>wetland.<span class="fl">31.</span>km<span class="sc">$</span>method</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;KM&quot;</span></span></code></pre></div>
<p>In this case, this matches the way we obtained our initial
classification. In general, however, we may have a classification
obtained following an informal (or unknown) procedure, and we will
choose the clustering model according to our preferences for
assignments. Once we have our object <code>vegclust</code> we can use
function <code>vegclass()</code> to <em>assign</em> the second set of
observations according to the membership rule of the k-means cluster
model:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>wetland.<span class="fl">10.</span>km <span class="ot">=</span> <span class="fu">vegclass</span>(wetland.<span class="fl">31.</span>km, wetland<span class="fl">.10</span>)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="fu">defuzzify</span>(wetland.<span class="fl">10.</span>km)<span class="sc">$</span>cluster</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  29  33  24  36  37  41  27  32  35  38 </span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;2&quot; &quot;2&quot; &quot;1&quot; &quot;2&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot;</span></span></code></pre></div>
<p>The same procedure can be repeated using dissimilarity matrices.
First, we call <code>as.vegclust()</code> to create a vegclust
object:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>wetland.<span class="fl">31.</span>km.d <span class="ot">=</span> <span class="fu">as.vegclust</span>(<span class="fu">dist</span>(wetland<span class="fl">.31</span>), groups)</span></code></pre></div>
<p>After that, we need a matrix of distances between the set of
observations to be assigned and the original set of 31 observations.
This can be obtained from the original distance matrix including all
pairs of observations:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>wetland.d.<span class="fl">10.31</span> <span class="ot">=</span> <span class="fu">as.data.frame</span>(<span class="fu">as.matrix</span>(dchord)[<span class="dv">32</span><span class="sc">:</span><span class="dv">41</span>,<span class="dv">1</span><span class="sc">:</span><span class="dv">31</span>])</span></code></pre></div>
<p>Once we have these two objects we can use function
<code>vegclass()</code> to <em>assign</em> the second set of
observations according to the membership rule of the k-means cluster
model:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>wetland.d.<span class="fl">11.</span>km <span class="ot">=</span> <span class="fu">vegclass</span>(wetland.<span class="fl">31.</span>km.d,wetland.d.<span class="fl">10.31</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="fu">defuzzify</span>(wetland.d.<span class="fl">11.</span>km)<span class="sc">$</span>cluster</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  29  33  24  36  37  41  27  32  35  38 </span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;2&quot; &quot;2&quot; &quot;1&quot; &quot;2&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot;</span></span></code></pre></div>
<p>Note that in both cases all the objects of the second set were
assigned to the nearest cluster. What if we want to determine whether it
is more appropriate for any of the objects to define a new vegetation
type? In that is case, we may do better by using noise clustering. We
can choose, for example, the hard noise clustering (HNC) model:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>wetland.<span class="fl">31.</span>nc <span class="ot">=</span> <span class="fu">as.vegclust</span>(wetland<span class="fl">.31</span>, groups, <span class="at">method=</span><span class="st">&quot;HNC&quot;</span>, </span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>                            <span class="at">dnoise =</span> <span class="fl">0.8</span>)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>wetland.<span class="fl">10.</span>nc <span class="ot">=</span> <span class="fu">vegclass</span>(wetland.<span class="fl">31.</span>nc, wetland<span class="fl">.10</span>)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="fu">defuzzify</span>(wetland.<span class="fl">10.</span>nc)<span class="sc">$</span>cluster</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  29  33  24  36  37  41  27  32  35  38 </span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;N&quot; &quot;2&quot; &quot;N&quot; &quot;N&quot; &quot;N&quot; &quot;N&quot; &quot;N&quot; &quot;N&quot; &quot;N&quot; &quot;1&quot;</span></span></code></pre></div>
<p>An additional parameter is needed: the distance to the noise class
‘dnoise’, <span class="math inline">\(\delta\)</span>. This can be set
either conventionally (depending on the level of abstraction of
vegetation types) or by relying on the variance of the original clusters
<span class="citation">(De Cáceres, Oliva, and Font 2006)</span>. The
results of the noise clustering model show that several of the ten
objects are assigned to the noise class (‘N’), which indicates that some
of them could be used to define a new cluster.</p>
</div>
<div id="extending-vegetation-classifications" class="section level3">
<h3>Extending vegetation classifications</h3>
<p>Allowing vegetation classifications to be dynamic entities, in the
sense that they may be modified or extended as new surveys are conducted
(or in general, when new data becomes available) increases their
usability <span class="citation">(De Cáceres, Font, and Oliva 2010;
Wiser and De Cáceres 2012)</span>. The aim here is to preserve the two
prototypes of the initial classification and let <code>vegclust</code>
to define a new vegetation type.</p>
<div id="conforming-vegetation-data-sets" class="section level4">
<h4>Conforming vegetation data sets</h4>
<p>When new vegetation data becomes available, the set of species in the
new data set will not normally be the same as the set of species used in
the original classification exercise. In this situation, the
practitioner will needs to bring the two sets of samples to the same
resemblance space. In our example we divided our initial data set into
two subsets of 31 and 10 sites, respectively
(i.e. <code>wetland.31</code> and <code>wetland.10</code>). Thus, our
original data set had a common set of species. However, we will now
pretend that <code>wetland.31</code> and <code>wetland.10</code> were
obtained independently. A useful function to create a common space of
species for two sets of vegetation observations is
<code>conformveg()</code>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>cf <span class="ot">=</span> <span class="fu">conformveg</span>(wetland<span class="fl">.31</span>, wetland<span class="fl">.10</span>)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>wetland.<span class="fl">31.</span>cf<span class="ot">&lt;-</span> cf<span class="sc">$</span>x</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>wetland.<span class="fl">10.</span>cf<span class="ot">&lt;-</span> cf<span class="sc">$</span>y</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="fu">dim</span>(wetland.<span class="fl">31.</span>cf)</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 31 33</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="fu">dim</span>(wetland.<span class="fl">10.</span>cf)</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 10 33</span></span></code></pre></div>
<p>The only difference between these new objects and the preceeding ones
is that they include extra columns with zeros, so that the set of
columns (i.e. species) match between the two data sets.</p>
</div>
<div id="re-calculating-the-centroids-of-the-initial-classification" class="section level4">
<h4>Re-calculating the centroids of the initial classification</h4>
<p>Another step we need to conduct before calling <code>vegclust</code>
is to re-calculate the centroids of the initial classification in the
resemblance space of all species. Thus, we need to call
<code>clustcentroid()</code> using the conformed data set as input:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>fixed <span class="ot">=</span> <span class="fu">clustcentroid</span>(wetland.<span class="fl">31.</span>cf, groups)</span></code></pre></div>
<p>Again, these centroids are exactly like the original ones except that
they are expressed in a matrix that includes extra zeros for the new
species.</p>
</div>
<div id="calling-vegclust-with-fixed-prototypes" class="section level4">
<h4>Calling <code>vegclust</code> with fixed prototypes</h4>
<p>At this point we are ready to call function <code>vegclust()</code>
with the new data set (again, its conformed version):</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>wetland.nc <span class="ot">=</span> <span class="fu">vegclust</span>(wetland.<span class="fl">10.</span>cf, <span class="at">mobileCenters=</span><span class="dv">1</span>, </span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">fixedCenters =</span> fixed, </span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>                      <span class="at">method =</span> wetland.<span class="fl">31.</span>nc<span class="sc">$</span>method,</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>                      <span class="at">dnoise=</span>wetland.<span class="fl">31.</span>nc<span class="sc">$</span>dnoise, <span class="at">nstart=</span><span class="dv">10</span>)</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="fu">defuzzify</span>(wetland.nc)<span class="sc">$</span>cluster</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   29   33   24   36   37   41   27   32   35   38 </span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  &quot;N&quot; &quot;F3&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot;  &quot;N&quot;  &quot;N&quot;  &quot;N&quot; &quot;F2&quot;</span></span></code></pre></div>
<p>Here, the function <code>vegclust()</code> has renamed the original
clusters as ‘F2’ and ‘F3’ (indicating that they are now fixed), while
the new cluster is named ‘M1’.</p>
<p>Instead of relying on the Noise clustering model, we could have
chosen to use the K-means model to extend the classification:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>wetland.km <span class="ot">=</span> <span class="fu">vegclust</span>(wetland.<span class="fl">10.</span>cf, <span class="at">mobileCenters=</span><span class="dv">1</span>, </span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">fixedCenters =</span> fixed, </span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>                      <span class="at">method =</span> <span class="st">&quot;KM&quot;</span>,</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>                      <span class="at">nstart=</span><span class="dv">10</span>)</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="fu">defuzzify</span>(wetland.km)<span class="sc">$</span>cluster</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   29   33   24   36   37   41   27   32   35   38 </span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;F3&quot; &quot;F3&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;F2&quot; &quot;F2&quot;</span></span></code></pre></div>
<p>This avoids having objects in the Noise class. However, note that the
noise clustering model allows objects in the Noise to be classified
later on when new data becomes available, instead of forcing them to
belong to one cluster or the other (i.e. the partition restriction).</p>
</div>
<div id="extending-or-refining-classifications" class="section level4">
<h4>Extending or refining classifications?</h4>
<p>Instead of calling <code>vegclust()</code> with the new data set
only, we could have chosen to use the set of all vegetation
observations:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>wetland.nc <span class="ot">=</span> <span class="fu">vegclust</span>(<span class="fu">rbind</span>(wetland.<span class="fl">31.</span>cf,wetland.<span class="fl">10.</span>cf), <span class="at">mobileCenters=</span><span class="dv">1</span>, </span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">fixedCenters =</span> fixed, </span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>                      <span class="at">method =</span> wetland.<span class="fl">31.</span>nc<span class="sc">$</span>method,</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>                      <span class="at">dnoise=</span>wetland.<span class="fl">31.</span>nc<span class="sc">$</span>dnoise, <span class="at">nstart=</span><span class="dv">10</span>)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="fu">defuzzify</span>(wetland.nc)<span class="sc">$</span>cluster</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    5    8   13    4   17    3    9   21   16   14    2   15    1    7   10   40 </span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot;  &quot;N&quot; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot;  &quot;N&quot; &quot;F3&quot; </span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   23   25   22   20    6   18   12   39   19   11   30   34   28   31   26   29 </span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;F3&quot; &quot;F3&quot; &quot;F3&quot; &quot;F3&quot; &quot;F3&quot; &quot;F3&quot; &quot;F3&quot; &quot;F3&quot; &quot;F3&quot; &quot;F3&quot;  &quot;N&quot; &quot;M1&quot;  &quot;N&quot; &quot;M1&quot;  &quot;N&quot;  &quot;N&quot; </span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   33   24   36   37   41   27   32   35   38 </span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;F3&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot;  &quot;N&quot;  &quot;N&quot;  &quot;N&quot; &quot;F2&quot;</span></span></code></pre></div>
<p>Note that some of the objects in the first data set may have been
reassigned (to a different cluster or to the Noise class). While the
centroids of the original classification are preserved, the membership
of particular objects may change because the classification now includes
new prototypes to which objects may be assigned. Using the complete data
set instead of the new data implies that the used is ready to accept
these reassignments. If the new memberships were strikingly different
from the original ones, one might decide to start the three group
classification from scratch.</p>
</div>
<div id="using-vegclustdist-with-fixed-prototypes" class="section level4">
<h4>Using <code>vegclustdist()</code> with fixed prototypes</h4>
<p>Extending vegetation classifications can also be done in the
distance-based mode. In this case we do not have explicit coordinates
for fixed prototypes, but we may have the distances to these centers. To
begin our example we use the distances to the two clusters that we
obtained at the stage of assigning new observations:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>fixedDist <span class="ot">=</span> wetland.d.<span class="fl">11.</span>km<span class="sc">$</span>dist2clusters</span></code></pre></div>
<p>With this information, we can now call <code>vegclustdist()</code> to
define a new cluster while accounting for the previous ones:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>wetland.km.d <span class="ot">=</span> <span class="fu">vegclustdist</span>(<span class="fu">dist</span>(wetland<span class="fl">.10</span>), <span class="at">mobileMemb =</span> <span class="dv">1</span>,</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>                            <span class="at">fixedDistToCenters=</span>fixedDist, </span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>                            <span class="at">method =</span> <span class="st">&quot;KM&quot;</span>,</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>                            <span class="at">nstart=</span><span class="dv">10</span>)</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="fu">defuzzify</span>(wetland.km.d)<span class="sc">$</span>cluster</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   29   33   24   36   37   41   27   32   35   38 </span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;F3&quot; &quot;F3&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;F2&quot; &quot;F2&quot;</span></span></code></pre></div>
<p>Analogously to <code>vegclust</code>, we could have chosen to use the
set of all vegetation observations. In this case, we need to pool the
distances to the centers:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>fixedDist <span class="ot">=</span> <span class="fu">rbind</span>(wetland.<span class="fl">31.</span>km.d<span class="sc">$</span>dist2clusters, wetland.d.<span class="fl">11.</span>km<span class="sc">$</span>dist2clusters)</span></code></pre></div>
<p>And then we call <code>vegclustdist()</code> using the full distance
matrix:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>wetland.km.d <span class="ot">=</span> <span class="fu">vegclustdist</span>(dchord, <span class="at">mobileMemb =</span> <span class="dv">1</span>,</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>                            <span class="at">fixedDistToCenters=</span>fixedDist, </span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>                            <span class="at">method =</span> <span class="st">&quot;KM&quot;</span>,</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>                            <span class="at">nstart=</span><span class="dv">10</span>)</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a><span class="fu">defuzzify</span>(wetland.km.d)<span class="sc">$</span>cluster</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    5    8   13    4   17    3    9   21   16   14    2   15    1    7   10   40 </span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot; &quot;F2&quot; &quot;F3&quot; </span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   23   25   22   20    6   18   12   39   19   11   30   34   28   31   26   29 </span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;F3&quot; &quot;F3&quot; &quot;F3&quot; &quot;F3&quot; &quot;F3&quot; &quot;F3&quot; &quot;F3&quot; &quot;F3&quot; &quot;F3&quot; &quot;F3&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;F3&quot; &quot;F3&quot; </span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   33   24   36   37   41   27   32   35   38 </span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &quot;F3&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;M1&quot; &quot;F2&quot; &quot;F2&quot;</span></span></code></pre></div>
<p>As before, some objects may be reclassified in different clusters
when using this option.</p>
</div>
</div>
</div>
<div id="cluster-characterization" class="section level2">
<h2>Cluster characterization</h2>
<p>In this section we show how to use auxiliary functions that allow
cluster properties to be extracted from an input classification. In all
examples we will use this <em>a priori</em> classification of our data
set:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>groups <span class="ot">=</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="dv">1</span>, <span class="dv">17</span>), <span class="fu">rep</span>(<span class="dv">2</span>, <span class="dv">14</span>), <span class="fu">rep</span>(<span class="dv">3</span>,<span class="dv">10</span>))</span></code></pre></div>
<div id="cluster-prototypes-clustcentroid-and-clustmedoid" class="section level3">
<h3>Cluster prototypes: <code>clustcentroid()</code> and
<code>clustmedoid()</code></h3>
<p>Functions <code>clustcentroid()</code> and <code>clustmedoid()</code>
allow the cluster prototypes to be calculated according to an input
classification structure, which can be specified using either a cluster
vector or a membership matrix.</p>
<p>For example, with <code>clustcentroid()</code> we can calculate the
coordinates of the centroids of the initial groups using:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>centroids <span class="ot">=</span> <span class="fu">clustcentroid</span>(wetlandchord, groups)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(centroids, <span class="at">dig=</span><span class="dv">3</span>)</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Abefic Merhed Alyvag Pancam Abemos Melcor Ludoct Eupvac Echpas Passcr Poa2</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 1  0.000  0.000  0.009  0.009  0.000  0.054  0.000  0.020  0.031  0.000 0.00</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2  0.013  0.015  0.036  0.088  0.000  0.178  0.000  0.090  0.116  0.000 0.01</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 3  0.000  0.047  0.000  0.371  0.036  0.253  0.019  0.182  0.061  0.026 0.00</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Carhal Dendio Casobt Aesind Cyprot Ipocop Cynarc Walind Sessp. Phynod Echell</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 1  0.064  0.000  0.016  0.009  0.000  0.000  0.000  0.068  0.144  0.090  0.022</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2  0.036  0.000  0.000  0.064  0.179  0.028  0.106  0.055  0.117  0.506  0.119</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 3  0.000  0.027  0.000  0.019  0.039  0.018  0.301  0.090  0.138  0.204  0.158</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Helind Ipoaqu Orysp. Elesp. Psespi Ludads Polatt  Poa1 Helcri Physp. Goopur</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 1  0.112  0.055  0.609  0.164  0.192  0.204  0.097 0.000  0.000   0.00   0.00</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2  0.138  0.048  0.126  0.125  0.027  0.000  0.000 0.013  0.013   0.00   0.00</span></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 3  0.090  0.037  0.172  0.000  0.000  0.000  0.000 0.000  0.000   0.02   0.02</span></span></code></pre></div>
<p>As medoids are prototypes that are chosen among the objects to be
classified, function <code>clustmedoid()</code> does not return
coordinates but the indices of objects. The following code uses the
medoid hard cluster equation to determine the medoids of each
cluster:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>medoids <span class="ot">=</span> <span class="fu">clustmedoid</span>(wetlandchord, groups)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>medoids</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  2 12 41 </span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 11 23 37</span></span></code></pre></div>
<p>The value returned by function <code>medoid()</code> is a vector of
indices with the corresponding object names (which are numbers in this
particular case). If the classification structure is a fuzzy membership
matrix, the cluster centroids or medoids are determined using the fuzzy
centroid or fuzzy medoid equation, respectively.</p>
</div>
<div id="cluster-internal-variability-clustvar" class="section level3">
<h3>Cluster internal variability: <code>clustvar()</code></h3>
<p>Vegetation types may differ in their internal variability. The
function <code>clustvar()</code> allows the amount of compositional
variation (i.e. beta diversity) observed among the sites of sites
belonging to each cluster to be determined. For clusters whose prototype
is a centroid, this is calculated as the mean of squared distances from
each object of the group to the group centroid. For example, the
variability for a given group <span class="math inline">\(i\)</span>
would be: <span class="math display">\[\begin{equation}
Var(i) = \sum_{j=1}^{n_k}{e_{ij}^2}/n_i
\end{equation}\]</span> Note that division is by <span class="math inline">\(n_i\)</span> and not by <span class="math inline">\((n_i-1)\)</span>, which would give an unbiased
sample estimate. Thus, the variances calculated in
<code>clustvar()</code> are population variances. For example, the
variances of the three groups in our examples are:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="fu">clustvar</span>(wetlandchord, groups)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;         1         2         3 </span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 0.4554668 0.5466579 0.5293836</span></span></code></pre></div>
<p>The reason why population values are produced, instead of sample
estimates, is because it allows the variance to be calculated using
fuzzy membership values: <span class="math display">\[\begin{equation}
Var(i) = \frac{\sum_{j=1}^{n}u_{ij}^me_{ij}^2}{\sum_{j=1}^n{u_{ij}^m}}
\end{equation}\]</span></p>
<p>Cluster variances can also be obtained using distance or
dissimilarity matrices. In this case, the variance for a given group is
calculated as: <span class="math display">\[\begin{equation}
Var(i) = \frac{1}{n_i^2} \sum_{k=1}^{n_i}\sum_{l=1}^{n_i}{d_{kl}^2}
\end{equation}\]</span> Again, division by <span class="math inline">\(n_i(n_i-1)\)</span> instead of <span class="math inline">\(n_i^2\)</span> would give an unbiased variance
estimate. Because in our example the community data had been transformed
using the chord transformation, the same variance values can be obtained
using a distance matrix with chord distances:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="fu">clustvar</span>(dchord, groups)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;         1         2         3 </span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 0.4554668 0.5466579 0.5293836</span></span></code></pre></div>
<p>Finally, if no classification structure is provided function
<code>clustvar()</code> will return the overall variance (beta
diversity) of the data table:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="fu">clustvar</span>(wetlandchord)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.6751038</span></span></code></pre></div>
</div>
<div id="distance-between-clusters-interclustdist" class="section level3">
<h3>Distance between clusters: <code>interclustdist()</code></h3>
<p>Calculating distance between pairs of cluster prototypes is useful to
determine which vegetation types are more similar and which are more
distinct. When prototypes of vegetation types are chosen to be cluster
medoids, then the resemblance between vegetation types can be defined as
the resemblance between the corresponding medoids:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="fu">as.dist</span>(<span class="fu">as.matrix</span>(dchord)[medoids,medoids])</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;           2       12</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 12 1.344006         </span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 41 1.093926 1.363297</span></span></code></pre></div>
<p>In contrast, if prototypes of vegetation types are chosen to be
cluster centroids, the distance between two vegetation types should be
defined as the distance between the cluster centroids. Following our
example, we can simply use function <code>dist()</code> on the matrix of
centroid coordinates:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dist</span>(centroids)</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;           1         2</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2 0.7624211          </span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 3 0.8004329 0.5298008</span></span></code></pre></div>
<p>Alternatively, the function <code>interclustdist()</code> allows the
distance between pairs of centroids to be calculated without the
coordinates of centroids being supplied. Instead, the matrix of
distances between objects is used. For example, if the distance between
the centroids of groups <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> is desired, we can calculate the
squared distance by: <span class="math display">\[\begin{equation}
d^2(i,j)=\frac{\sum_{k=1}^{n}\sum_{l=1}^{n}{u_{ik}^mu_{jl}^m{d_{kl}}^2}}{\sum_{k=1}^n{u_{ik}^m}\sum_{l=1}^n{u_{jl}^m}}
- Var(i) - Var(j)
\end{equation}\]</span> Using the former equation in our example would
result in:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="fu">interclustdist</span>(dchord,groups)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;           1         2</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2 0.7624211          </span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 3 0.8004329 0.5298008</span></span></code></pre></div>
<p>which returns the same values as before.</p>
</div>
<div id="constancy-classes-clustconst" class="section level3">
<h3>Constancy classes: <code>clustconst()</code></h3>
<p>One way of characterizing a vegetation type is to examine how
frequently each species occurs in vegetation observations belonging to
the type. This frequency is often called <em>constancy</em> and the
table that contains the constancy of all species in all vegetation types
is called <em>constancy table</em>. The function
<code>clustconst()</code> allows this table to be calculated:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>c <span class="ot">=</span> <span class="fu">clustconst</span>(wetlandchord, <span class="at">memb =</span> <span class="fu">as.memb</span>(groups))</span></code></pre></div>
<p>The R object returned by <code>clustconst()</code> can be examined in
several ways. First, it is useful to print the constancy table ordering
species from high to low constancy for each cluster:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>d<span class="ot">=</span><span class="fu">summary</span>(c, <span class="at">mode=</span><span class="st">&quot;all&quot;</span>)</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; ------------ 3 -------------</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;            3     2     1</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Pancam 1.000 0.357 0.059</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Melcor 1.000 0.786 0.294</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Eupvac 0.800 0.357 0.118</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Sessp. 0.600 0.500 0.412</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Echell 0.600 0.357 0.118</span></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; ------------ 2 -------------</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;            3     2     1</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Phynod 0.400 0.714 0.118</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Helind 0.300 0.643 0.471</span></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Elesp. 0.000 0.571 0.529</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; ------------ 1 -------------</span></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;            3     2     1</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Orysp. 0.300 0.286 1.000</span></span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Ludads 0.000 0.000 0.824</span></span></code></pre></div>
<p>Alternatively, we can examine the constancy vector of each vegetation
type:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(c, <span class="at">mode=</span><span class="st">&quot;cluster&quot;</span>, <span class="at">name=</span><span class="fu">names</span>(c)[<span class="dv">1</span>])</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Orysp. 1.000 </span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Ludads 0.824 </span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Elesp. 0.529</span></span></code></pre></div>
</div>
</div>
<div id="bibliography" class="section level2 unnumbered">
<h2 class="unnumbered">Bibliography</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-Bezdek1981" class="csl-entry">
Bezdek, James C. 1981. <em><span class="nocase">Pattern recognition with
fuzzy objective functions</span></em>. New York: Plenum Press.
</div>
<div id="ref-Bowman1986" class="csl-entry">
Bowman, D. M. J. S., and B A Wilson. 1986. <span>“<span class="nocase">Wetland vegetation pattern on the Adelaide River flood
plain, Northern Territory, Australia.</span>”</span> <em>Proceedings of
the Royal Society of Queensland</em> 97: 69–77.
</div>
<div id="ref-Dale1995" class="csl-entry">
Dale, MB. 1995. <span>“<span class="nocase">Evaluating classification
strategies</span>.”</span> <em>Journal of Vegetation Science</em> 6 (3):
437–40. <a href="https://onlinelibrary.wiley.com/doi/10.2307/3236243/abstract">https://onlinelibrary.wiley.com/doi/10.2307/3236243/abstract</a>.
</div>
<div id="ref-Dave1991" class="csl-entry">
Dave, R N. 1991. <span>“<span class="nocase">Characterization and
detection of noise in clustering</span>.”</span> <em>Pattern Recognition
Letters</em> 12 (11): 657–64.
</div>
<div id="ref-Dave1997" class="csl-entry">
Dave, R. N., and R. Krishnapuram. 1997. <span>“<span class="nocase">Robust clustering methods: a unified view</span>.”</span>
<em>IEEE Transactions on Fuzzy Systems</em> 5 (2): 270–93. <a href="https://doi.org/10.1109/91.580801">https://doi.org/10.1109/91.580801</a>.
</div>
<div id="ref-DeCaceres2010a" class="csl-entry">
De Cáceres, Miquel, Xavier Font, and Francesc Oliva. 2010. <span>“<span class="nocase">The management of vegetation classifications with fuzzy
clustering</span>.”</span> <em>Journal of Vegetation Science</em> 21
(6): 1138–51. <a href="https://doi.org/10.1111/j.1654-1103.2010.01211.x">https://doi.org/10.1111/j.1654-1103.2010.01211.x</a>.
</div>
<div id="ref-DeCaceres2006" class="csl-entry">
De Cáceres, Miquel, Francesc Oliva, and Xavier Font. 2006. <span>“<span class="nocase">On relational possibilistic clustering</span>.”</span>
<em>Pattern Recognition</em> 39 (11): 2010–24. <a href="https://doi.org/10.1016/j.patcog.2006.04.008">https://doi.org/10.1016/j.patcog.2006.04.008</a>.
</div>
<div id="ref-Hathaway1994" class="csl-entry">
Hathaway, R J, and James C Bezdek. 1994. <span>“<span class="nocase">NERF c-means: Non-euclidean relational fuzzy
clustering</span>.”</span> <em>Pattern Recognition</em> 27 (3): 429–37.
</div>
<div id="ref-Hathaway1989" class="csl-entry">
Hathaway, R J, J W Davenport, and James C Bezdek. 1989. <span>“<span class="nocase">Relational duals of the c-means clustering
algorithms</span>.”</span> <em>Pattern Recognition</em> 22 (2): 205–12.
</div>
<div id="ref-Hathaway1996" class="csl-entry">
Hathaway, R, J. C. Bezdek, and J Davenport. 1996. <span>“<span class="nocase">On relational data versions of c-means
algorithms</span>.”</span> <em>Pattern Recognition Letters</em> 17 (6):
607–12. <a href="https://doi.org/10.1016/0167-8655(96)00025-6">https://doi.org/10.1016/0167-8655(96)00025-6</a>.
</div>
<div id="ref-Krishnapuram1999" class="csl-entry">
Krishnapuram, Raghu, Anupam Joshi, and Liyu Yi. 1999. <span>“<span class="nocase">A Fuzzy relative of the k-medoids algorithm with
application to web document and snippet clustering</span>.”</span> In
<em>IEEE International Fuzzy Systems</em>, 1281–86. <a href="https://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=790086">https://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=790086</a>.
</div>
<div id="ref-Krishnapuram1993" class="csl-entry">
Krishnapuram, R., and J. M. Keller. 1993. <span>“<span class="nocase">A
possibilistic approach to clustering</span>.”</span> <em>IEEE
Transactions on Fuzzy Systems</em> 1 (2): 98–110. <a href="https://doi.org/10.1109/91.227387">https://doi.org/10.1109/91.227387</a>.
</div>
<div id="ref-Krishnapuram1996" class="csl-entry">
———. 1996. <span>“<span class="nocase">The possibilistic C-means
algorithm: insights and recommendations</span>.”</span> <em>IEEE
Transactions on Fuzzy Systems</em> 4 (3): 385–93. <a href="https://doi.org/10.1109/91.531779">https://doi.org/10.1109/91.531779</a>.
</div>
<div id="ref-Legendre2001" class="csl-entry">
Legendre, Pierre, and Eugene Gallagher. 2001. <span>“<span class="nocase">Ecologically meaningful transformations for ordination of
species data</span>.”</span> <em>Oecologia</em> 129 (2): 271–80. <a href="https://doi.org/10.1007/s004420100716">https://doi.org/10.1007/s004420100716</a>.
</div>
<div id="ref-MacQueen1967" class="csl-entry">
MacQueen, J. 1967. <span>“<span class="nocase">Some methods for
classification and analysis of multivariate observation</span>.”</span>
In, edited by L M LeCam and J Neyman, 281–97. 0. Berkeley: University of
California Press.
</div>
<div id="ref-Moravec1989" class="csl-entry">
Moravec, J. 1989. <span>“<span class="nocase">Influences of the
individualistic concept of vegetation on syntaxonomy</span>.”</span>
<em>Vegetatio</em> 81 (1-2): 29–39. <a href="https://doi.org/10.1007/BF00045511">https://doi.org/10.1007/BF00045511</a>.
</div>
<div id="ref-Orloci1967" class="csl-entry">
Orlóci, L. 1967. <span>“<span class="nocase">An agglomerative method for
classification of plant comunities</span>.”</span> <em>Journal of
Ecology</em> 55 (0): 193–206.
</div>
<div id="ref-Wiser2012" class="csl-entry">
Wiser, Susan K., and Miquel De Cáceres. 2012. <span>“<span class="nocase">Updating vegetation classifications: an example with New
Zealand’s woody vegetation</span>.”</span> Edited by Sandor Bartha.
<em>Journal of Vegetation Science</em>, July, n/a–. <a href="https://doi.org/10.1111/j.1654-1103.2012.01450.x">https://doi.org/10.1111/j.1654-1103.2012.01450.x</a>.
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
