\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{natbib}
\usepackage{authblk}

%\VignetteIndexEntry{Learning how to use the vegclust package for vegetation classification}
%\VignettePackage{vegclust}

\title{How to use the \texttt{vegclust} package (ver. 1.6.0)}
\author[1]{Miquel De Cáceres}
\affil[1]{Centre Tecnològic Forestal de Catalunya. Ctra. St. Llorenç de Morunys km 2, 25280, Solsona, Catalonia, Spain}

\begin{document}
\SweaveOpts{concordance=TRUE}
\maketitle
\tableofcontents

<<echo=FALSE>>=
options(width=67)
@
\section{Introduction}
\subsection{What is this tutorial about?}
Classification of vegetation plot records involves different activities, including the design an appropriate vegetation survey, the use of a classification method to group vegetation observations and the characterization, validation and naming of the resulting vegetation groups. In this tutorial we focus in only one of this steps, namely to group vegetation observations, and we show how to conduct it with the help of the R package \texttt{vegclust}. Before starting our examples we need to load the \texttt{vegclust} package, which also loads the required R packages \texttt{vegan} and \texttt{permute}:
<<>>=
library(vegclust)
@

\subsection{Example vegetation data}
In order to illustrate the functions in \texttt{vegclust} we will use a small wetland vegetation data set, consisting of 41 sites and 33 species and published by \citet{Bowman1986}. The data is included with the \texttt{vegclust} package:
<<>>=
data(wetland)
dim(wetland)
@
For a number of reasons we will not detail here, the Euclidean distance is not an appropriate index to measure the resemblance in species composition between vegetation plot records. Therefore, we transform our community data using the chord transformation \citep{Legendre2001}, which divides each value by the norm of the row vector of the corresponding site: 
<<>>=
wetlandchord = decostand(wetland,"normalize")
@
Function \texttt{decostand} is provided within the \texttt{vegan} package. The Euclidean distance on the transformed data is equal to the chord distance \citep{Orloci1967} with respect to the raw community data:
<<>>=
dchord = dist(wetlandchord)
@
In some of our examples we will use \texttt{wetlandchord} or \texttt{dchord} indistinctively, because package \texttt{vegclust} allows conducting classification of vegetation from either a site-by-species data table or from a site-by-site dissimilarity matrix. In the next section we briefly explain the bases of the classification methods that are provided in the \texttt{vegclust} package. We later show how to run those methods with functions in the package.

\section{Clustering methods in \texttt{vegclust}}
\subsection{Resemblance space}

Generally speaking, the goal of clustering is to derive $c$ `natural' classes or clusters from a set of $n$ unlabelled objects. Those objects inside a `natural' cluster show a certain degree of closeness or similarity and the cluster itself shows a certain degree of isolation from other clusters. In classification of vegetation the $n$ `objects' to be grouped are plant communities (i.e. plot records or relevés) and the goal is to define vegetation types. 


When speaking of `closeness' or `similarity', we implicitly assume there is a way to assess the resemblance between the objects to be grouped. This can be obtained by describing our objects using a set of $p$ features (these are normally species in the case of vegetation) and specifying a resemblance measure (e.g. distance or dissimilarity). Let $\mathbf{X}=[x_{js}]$ be a site-by-species data table of dimensions $n\times p$, where $x_{js}$ is the abundance of species $s$ in site $j$, and let $d$ be an appropriate dissimilarity or distance measure. 

Another way to formalize the resemblance between objects is to directly give similarity or dissimilarity between pairs of objects in a symmetric resemblance matrix. Let $\mathbf{D}=[d_{ij}]$ a symmetric dissimilarity matrix of dimensions $n\times n$, where $d_{ij} = d(\mathbf{x}_i,\mathbf{x}_j)$ is the dissimilarity between objects $i$ and $j$. In classification of vegetation  $d_{ij} = d(\mathbf{x}_i,\mathbf{x}_j)$ will normally represent the compositional dissimilarity between plant communities $i$ and $j$.

Regardless of whether we use $\mathbf{X}$ or $\mathbf{D}$, we will speak here of \emph{resemblance space} and our objects (plant communities) will be formally represented as points in this space. Although we do not cover this topic in detail here, the reader should be aware that building an appropriate resemblance space is crucial in vegetation classification.

\subsection{Prototype-based clustering}
\emph{Prototype-based} clustering methods assume that the properties of objects in a cluster can be represented using a cluster \emph{prototype}, which is formalized as a point in the resemblance space. The problem is thus to find $c$ prototypes and assign the $n$ objects according to their closeness to those prototypes, such that the resulting clusters are compact and isolated one from another. 

All the clustering methods discussed here follow an \emph{alternate optimization} scheme, meaning that one group of parameters (e.g. the membership matrix) is optimized holding the other group (e.g. the cluster prototypes) fixed and vice versa. Assuming an initial cluster configuration, this is achieved by iterating the following three steps:
\begin{itemize} 
\item[(S.1)] Determine the prototype of each cluster $i$.
\item[(S.2)] Calculate $e_{ij}$, the distance from each object $j$ to the prototype of each cluster $i$.
\item[(S.3)] Calculate $u_{ij}$, the (hard or fuzzy) membership of each object $j$ to each cluster $i$ (i.e. re-assign all objects into clusters).
\end{itemize}
Each iteration improves the so called \emph{objective function} of the clustering method. The alternate optimization algorithm stops when there are no further changes in object memberships. More technically, it stops if the maximum difference in object membership values of the last two iterations does not exceed a user-specified threshold. The starting configuration of clusters is a critical issue in this kind of classification methods, because the iterations can led the alternate optimization algorithm to get stuck in a suboptimal value of the objective function. For this reason, several executions of the algorithm are usually tried, each one using a different starting configuration.

\subsection{Clustering models}
There are several prototype-based clustering models in the \texttt{vegclust} package. All of them following the iterative algorithm presented above. The differences between clustering models arise due to differences in the specific implementation of each step, resulting from different assumptions of how clusters should be defined. The clustering models can be divided according to their properties into:
\begin{itemize}
\item[a)] Whether object memberships are \textbf{fuzzy} or \textbf{hard} (crisp).
\item[b)] Whether cluster prototypes are \textbf{centroids} or \textbf{medoids}.
\item[c)] How to deal with outlier objects, which gives three kinds of models: \textbf{partitive}, \textbf{noise clustering} or \textbf{possibilistic clustering}.
\end{itemize}
In the following subsections we describe the implications of each of these decisions.

\subsubsection{Hard (crisp) or fuzzy memberships}

With the kind of classification methods described here, it is costumary to represent the classification of objects into groups using a $c\times n$  membership matrix, $\mathbf{U}=[u_{ij}]$, where $u_{ij}$ is the degree of membership of object $j$ in cluster $i$.  The classification is said to be \emph{hard} when the $u_{ij}$ values are either 0 (object $j$ DOES NOT belong to cluster $i$) or 1 (object $j$ DOES belong to cluster $i$). In contrast, if the classification is \emph{fuzzy} the membership of its objects is expressed through a degree of membership bounded between 0 (i.e. the object does not belong to the set at all) and 1 (i.e. the object belongs completely to the set).

The advantages of using fuzzy set theory in vegetation are that it acknowledges the individualistic concept of vegetation \citep{Moravec1989}, and therefore avoids assuming that relevés are unequivocal representatives of a type without admixture of any other types \citep{Dale1995}. 

\subsubsection{Centroids or medoids}
The \emph{centroid} of a cluster $i$ that contains $n_i$ objects is a vector $\mathbf{c}_i$ whose coordinates are the average, in each dimension $s$, of the coordinates of the $n_i$ objects belonging to the cluster. In vector notation:
\begin{equation}\label{eq:centroid}
\mathbf{c}_{i} = \frac{\sum_{j=1}^{n_i}{\mathbf{x}_{j}}}{n_i}
\end{equation}
The centroid has the property that minimizes the sum of squared Euclidean distances between itself and each point belonging to the cluster. Equation~\ref{eq:centroid} can be generalized to the case of a fuzzy cluster by weighting the coordinates each object by its degree of membership to the cluster, $u_{ij}$:
\begin{equation}\label{eq:centroidfuzzy}
\mathbf{c}_{i} = \frac{\sum_{j=1}^n{u_{ij}^m\mathbf{x}_{j}}}{\sum_{j=1}^n{u_{ij}^m}}
\end{equation}
In equation~\ref{eq:centroidfuzzy}, $m > 0$ is the \emph{fuzziness exponent}, which is used to modulate the influence of fuzzy memberships in the calculation of the centroids. If $m$ is very large only the objects whose membership is close to 1 will have an influence in the centroid. On the contrary, if $m$ is small (i.e. close to 0) then all $n$ objects will have influence equally the centroid and it will approach the overall data center.  

A \emph{medoid} of a cluster $i$ that contains $n_i$ objects is defined as the object, chosen among the $n_i$ objects, for which the sum of dissimilarities to all the $n_i$ objects is minimal i.e. it is a most centrally located point in the cluster. Formally, the medoid is the object $k$ for which:
\begin{equation}\label{eq:medoid}
\sum_{j=1}^{n_i}{d(\mathbf{x}_k,\mathbf{x}_j)}
\end{equation}
is minimal. When using fuzzy logic, the medoid of cluster $i$ is defined as the object $k$ (among all $n$ objects) that minimizes:
\begin{equation}\label{eq:medoidfuzzy}
\sum_{j=1}^n{u_{ij}^md(\mathbf{x}_k,\mathbf{x}_j)}
\end{equation}
Note that, because the medoid is a point chosen among the $n$ input objects, we do not need to calculate its coordinates (although see explanation below for centroids), moreover, the distance between a medoid and the other objects (step S.2 in the alternate optimization algorithm) will be readily available from the beginning, so it does not need to be computed. All this makes dealing with medoids computationally much faster than dealing with centroids.

\subsubsection{Partitive clustering}
A clustering method is called \emph{partitive} if object memberships (crisp or fuzzy) are constrained to sum to one for each object:
\begin{equation}\label{eq:partition}
\sum_{i=1}^c{u_{ij}}=1
\end{equation}
This constrain is usually referred to as the \emph{partition restriction}. It ensures that all objects will be classified as either belonging to a single cluster or dividing their membership among different clusters. No objects will be left unclassified.

K-means (KM, also known as hard c-means) \citep{MacQueen1967} and Fuzzy c-means (FCM) \citep{Bezdek1981} are two, centroid-based, partitive clustering algorithms widely used in many unsupervised pattern recognition applications. The main difference between the two methods is that in KM every object belongs to a single cluster (i.e clusters are `hard') whereas in FCM the memberships are fuzzy and a given object may have some degree of membership for more than one cluster.

Cluster memberships (step S.3) are determined in KM simply by \emph{assigning each object to the cluster whose center is closest}. In the case of FCM, fuzzy memberships are calculated using the following formula:
\begin{equation}\label{eq:fcmmemb}
u_{ij} = \frac{1}{\sum_{l=1}^c{(e_{ij}/e_{lj})^{2/(m-1)}}}
\end{equation}
As said above, $m>1$ is the fuzziness coefficient. The smaller the value of $m$, the closer to a hard partition will be the result. If $m$ is set too high and the data is noisy the resulting partition may be completely fuzzy (i.e. where $u_{ij}=1/c$ for all objects and clusters) and therefore uninformative. 



As indicated above, KM and FCM are centroid-based, meaning they use equations~\ref{eq:centroid} and~\ref{eq:centroidfuzzy}, respectively, for step S.1. The corresponding medoid-based methods are Hard C-medoids and Fuzzy C-medoids, which instead use equations~\ref{eq:medoid} and~\ref{eq:medoidfuzzy}, respectively \citep{Krishnapuram1999}.

\subsubsection{Noise clustering}
The noise clustering (NC) method \citep{Dave1991} is an attempt to make the FCM method more robust to the effect of outliers. The rationale underlying NC is the following: if an object is an outlier, this means that it lies far from all cluster prototypes and, therefore, it should have low membership values to all clusters. In order to achieve these low memberships, the NC considers an additional cluster, called \emph{Noise}. This class is represented by an imaginary `prototype' that lies at a constant distance $\delta$ from all the data points. Even if such a prototype does not really exist, the effect of including the Noise class is that it `captures' objects that lie farther than $\delta$ from all the $c$ `good' prototypes. The NC membership function (step S.3) for the `good' clusters is:
\begin{equation}\label{eq:noisememb}
u_{ij} = \frac{1}{(e_{ij}/\delta)^{2/(m-1)}+\sum_{l=1}^c{(e_{ij}/e_{lj})^{2/(m-1)}}}
\end{equation}
whereas the fuzzy membership to the Noise class, $u_{Nj}$, is one minus the sum of memberships to the good clusters. 
\begin{equation}\label{eq:noiseclassmemb}
u_{Nj} = 1 - \sum_{i=1}^c{u_{ij}}
\end{equation}
Outlier objects have small membership values to the $c$ good clusters because the first term in the denominator of equation~\ref{eq:noisememb} is large. The smaller the $\delta$, the higher will be memberships to the Noise class. In contrast, large values of $\delta$ make NC equivalent to FCM. The fuzziness exponent $m$ has in NC the same interpretation as in FCM. Including the Noise class has the effect of relaxing the partition restriction. In NC, the partition restriction is fulfilled when considering all $c$ good clusters and the Noise class.

Note that, like FCM and KM, we can define a `hard' counterpart of the (fuzzy) noise clustering method. Indeed, the hard noise clustering (HNC) method differs from the fuzzy one in that memberships are not fuzzy. Like KM, its membership function can be described verbally. One assigns the object to the noise class if the distances to all cluster centers is larger than $\delta$. Otherwise, one assigns the object to the  cluster whose center is closest, as in KM.

The noise clustering method was originally defined with centroids as prototypes. However, either hard or fuzzy noise clustering can be applied to medoids instead of centroids. While we have not found any references about this possibility, the corresponding algorithms could be named `hard noise clustering with medoids' (HNCdd) and `(fuzzy) noise clustering with medoids' (NCdd).

\subsubsection{Possibilistic clustering}
Possibilistic C-means \citep{Krishnapuram1993, Krishnapuram1996} is another modification of FCM seeking increased cluster robustness. The partition restriction is eliminated in PCM, which produces $c$ independent fuzzy clusters, each corresponding to a dense region of points. Whereas the FCM and NC membership functions compare the distance from the object to the cluster of interest, $e_{ij}$, with the distances to the remaining centres (and to the noise class in the case of NC), in PCM the membership value for a given object to a cluster does not depend on the distances to the remaining cluster centres. Instead, the distance to the cluster of interest is compared to a reference distance ($\eta_i$):
\begin{equation}\label{eq:possibilisticmemb}
u_{ij} = \frac{1}{1+(e^2_{ij}/\eta_i)^{1/(m-1)}}
\end{equation}
The reference distance is a parameter that must be provided for each cluster. All objects whose distance to the cluster center is smaller than $\eta_i$ will obtain a membership value higher than 0.5.  

Cluster repulsion is eliminated in PCM, which increases cluster mobility. Good estimation of $\eta_i$ is crucial for the success of the PCM method \citep{DeCaceres2006}. The high cluster mobility resulting from the inadequate initialization of $\eta_i$ can lead to a miss of cluster structures, even with the correct partition as initial starting configuration. A single PCM run can be regarded as $c$ independent runs of NC, each looking for a single cluster and where $\delta_i^2=\eta_i$ \citep{Dave1997}. In vegetation data plant communities with intermediate characteristics are frequent. This fact makes the PCM method impractical for classification of vegetation, because without cluster repulsion PCM clusters are frequently highly mobile and converge to the same cluster, leaving large parts of the data unassigned \citep{DeCaceres2010a}.


\subsection{Dissimilarity-based duals}
All the clustering methods presented above can be executed on a resemblance space described using  either $\mathbf{X}$ or $\mathbf{D}$. The latter case avoids dealing with the coordinates of prototypes explicitly.
\subsubsection{Medoid-based clustering and dissimilarity matrices}
Because medoids are selected among the objects to be classified, it is obvious that the distance to the cluster prototypes, $e_{ij}$, can be drawn from a symmetric matrix of pairwise distances between objects calculated before starting the alternate optimization algorithm. In other words, one can conduct medoid-based clustering on a site-by-site distance matrix instead of using a site-by-species rectangular matrix. Moreover, one can straightforwardly skip the use of Euclidean distance and use a dissimilarity measure more appropriate for ecological data.
\subsubsection{Centroid-based clustering and dissimilarity matrices}
When dealing with centroids, it may seem unavoidable to calculate centroid coordinates (step S.1) prior to calculating the (squared) Euclidean distances to cluster centers $e_{ij}$ (step S.2): 
\begin{equation}\label{eq:dist2clustersrect}
e_{ij}^2 = \| \mathbf{c}_i-\mathbf{x}_j \|^2
\end{equation}
However, there is a mathematical trick that avoids calculating the coordinates $\mathbf{c}_i$ explictly. Let $\mathbf{D}$ be the matrix of Euclidean distances between pairs of objects. We can obtain $e_{ij}^2$ as follows:
\begin{equation}\label{eq:dist2clustersdist}
e_{ij}^2 = \frac{1}{n_i}\sum_{l=1}^{n_i}{d_{lj}^2}- \frac{1}{2n_i^2}\sum_{k=1}^{n_i}\sum_{l=1}^{n_i}{d_{lk}^2}
\end{equation}
The left part of this equation is a sum of squared distances from the target object to all the other objects in the cluster. The right part of the equation is an average of squared distances between objects in the cluster. Equation~\ref{eq:dist2clustersdist} can be generalized to the case of a fuzzy cluster:
\begin{equation}\label{eq:dist2clustersdistfuzzy}
e_{ij}^2 = \frac{1}{\sum_{k=1}^n{u_{ik}^m}}\sum_{l=1}^{n_i}{d_{lj}^2}- \frac{1}{2\left(\sum_{k=1}^n{u_{ik}^m}\right)^2}\sum_{k=1}^{n}\sum_{l=1}^{n}{u_{ik}^mu_{il}^md_{lk}^2}
\end{equation}
Equations~\ref{eq:dist2clustersdist} and~\ref{eq:dist2clustersdistfuzzy} allow determining the Euclidean distance to a centroid without calculating its coordinates. Therefore, they allow conducting steps S.1 and S.2 in a single step. In other words, distance-based duals exist for centroid-based clustering methods when Euclidean distances are used in the resemblance space \citep{Hathaway1989, Hathaway1996}. 

If we transform the original data in order to emulate a distance like the chord, then the duality holds, although centroids are defined in the transformed space. What happens if the values in $\mathbf{D}$ were not calculated using the Euclidean distance? Equations~\ref{eq:dist2clustersdist} and~\ref{eq:dist2clustersdistfuzzy} are also valid for arbitrary dissimilarity measures, although there are important details to be remembered. These equations assume that the resemblance space is Euclidean (i.e. does not produce negative eigenvalues in principal coordinates analysis) and that centroids are appropriate prototypes for clusters. If the dissimilarities do not have the Euclidean property some oddities may arise \citep{Hathaway1994}. For example, it is possible to obtain negative $e_{ij}^2$ values, specially for groups of small size. In practice, however, when these negative distances occur they can be reset to zero \citep{DeCaceres2006}.

\section{Managing vegetation classifications}
\subsection{Creating classifications: \texttt{vegclust} and \texttt{vegclustdist}}
Functions \texttt{vegclust} and \texttt{vegclustdist} allow defining vegetation types from a set of unlabelled vegetation observations (i.e. relevés or plot records) using any of the clustering models explained in the previous section. While \texttt{vegclust} needs a rectangular site-by-species matrix, \texttt{vegclustdist} needs a symmetric site-by-site dissimilarity matrix.

\subsubsection{The K-means model}
The following piece of code produces a classification of our example data set into three groups using the K-means clustering model:
<<>>=
wetland.km = vegclust(x = wetlandchord, mobileCenters=3, 
                      method="KM", nstart=20)
@
The result is an object of class `vegclust', in fact a list with several components (method, parameters, prototypes, objective function, etc.): 
<<>>=
names(wetland.km)
@
One of the most important components is the membership matrix $\mathbf{U}$, which we show transposed here:
<<>>=
t(wetland.km$memb)
@
Another important component is the matrix containing the coordinates of cluster centroids (i.e. vectors $\mathbf{c}_i$ for each cluster):
<<>>=
round(wetland.km$mobileCenters, dig=3)
@
The same classification exercise can be conducted from the matrix of chord distances between objects if we use function \texttt{vegclustdist} instead of \texttt{vegclust}:
<<>>=
wetland.kmdist = vegclustdist(x = dchord, mobileMemb=3, 
                              method="KM", nstart = 20)
names(wetland.kmdist)
@
Note the different way to specify the number of clusters. In the case of \texttt{vegclustdist} we do not obtain cluster centroids, because they cannot be calculated explicitly:
<<>>=
wetland.kmdist$mobileCenters
@
But we do obtain cluster memberships:
<<>>=
t(wetland.kmdist$memb)
@
Because we used the same resemblance space (although in different form) in our examples, both \texttt{vegclust} and \texttt{vegclustdist} should give the same result provided the algorithm has not been stuck in a relative optimum of the objective function. Although both functions return objects of class `vegclust', we can identify whether calculations were done from dissimilarities or from rectangular matrices by inspecting the `mode' element of the list:
<<>>=
wetland.km$mode
wetland.kmdist$mode
@
In the following subsections we run \texttt{vegclust} using other clustering models, but the same examples could be made using \texttt{vegclustdist}.

\subsubsection{The Fuzzy C-means model}
Let us inspect the distance of each object to each cluster centroid:
<<>>=
round(t(wetland.km$dist2clusters), dig=2)
@
For many objects the distance to the cluster where they have been assigned is much smaller than the distance to other clusters. However, for some objects (such as `22', `29' or `35') the distance to the closest cluster center does not differ much from the distance to second closest one. Are those latter objects well assigned? Should these objects have intermediate degrees of membership instead of picking one cluster arbitrarily? The Fuzzy C-means cluster model allows obtaining fuzzy memberships instead of crisp memberships:
<<>>=
wetland.fcm = vegclust(x = wetlandchord, mobileCenters=3, 
                       method="FCM", m=1.2, nstart=20)
round(t(wetland.fcm$memb), dig=3)
@
A comparison of these memberships with the distance to the clusters shown before will reveal that  intermediate objects obtain fuzzier membership values than other objects. 

Although FCM is theoretically a better model than KM for vegetation classification, vegetation scientists are normally interested in crisp assignments. Function \texttt{defuzzify} allows turning a fuzzy membership matrix into a crisp one:
<<>>=
groups = defuzzify(wetland.fcm)$cluster
groups
table(groups)
@
Another way of defuzzifying the membership matrix is by setting a threshold of minimum fuzzy membership:
<<>>=
groups = defuzzify(wetland.fcm, method = "cut", alpha = 0.8)$cluster
groups
table(groups, useNA = "always")
@
With this second defuzzification approach intermediate objects are left unclassified (indicated as \texttt{NA}'s). It is important to realize that FCM fuzzy membership values depend on the fuzziness exponent $m$. In fact, if we run FCM with a very large $m$ value we will obtain uninformative results:
<<>>=
wetland.fcm2 = vegclust(x = wetlandchord, mobileCenters=3, 
                       method="FCM", m=10, nstart=20)
round(t(wetland.fcm2$memb), dig=3)
@


\subsubsection{The Noise clustering model}
In the previous two models, all objects were assigned, either completely to one cluster or dividing their membership among clusters (in other words, we stuck ourselves to the partition restriction). This may be appropriate in general, but it may cause problems if some plant assemblages describe rare species assemblages. These plant communities should better be classified as `outliers' and should not influence the prototypes. In the noise clustering (NC) model we allow outlier objects to be excluded from the classification: 
<<>>=
wetland.nc = vegclust(x = wetlandchord, mobileCenters=3,
                       method="NC", m=1.2, dnoise=0.8, nstart=20)
round(t(wetland.nc$memb), dig=2)
@
As with FCM, some objects have intermediate memberships. In addition, there are some objects with high membership to the Noise class, which indicates that they are distant from all `true' cluster centers. These objects can be considered `outliers' and are left unclassified:
<<>>=
groups = defuzzify(wetland.nc)$cluster
groups
table(groups)
@
Note that we can defuzzify the membership matrix using a threshold, as before, and determine both intermediates (`N') and outliers (`NA'):
<<>>=
groups = defuzzify(wetland.nc, method="cut", alpha=0.8)$cluster
groups
table(groups, useNA = "always")
@
In vegetation classification, distinguishing between an intermediate or an outlier will not be clearcut. Nevertheless, the distinction may be useful in practice because outlier objects may relate to vegetation patterns that exist in the study area but happen to be underrepresented in the sample. That is, outlier plant communities may be rare for the given vegetation data set only, in the sense that if new data is added they would belong to a  vegetation type. Alternatively, they may represent rare species assemblages for the study area. Distinguishing between one case or the other cannot be done without collecting more data \citep{Wiser2012}.

An advantage of the NC model over FCM or KM is that `outliers' do not influence the cluster centers. As a result, the cluster centers are more separated from each other than in the previous models. Compare the following distance matrices between cluster centers:
<<>>=
dist(wetland.km$mobileCenters)
dist(wetland.fcm$mobileCenters)
dist(wetland.nc$mobileCenters)
@
However, this particular advantage is also obtained (in partitive methods) if medoids are used as prototypes instead of centroids (see below).

\subsubsection{Medoid-based clustering}
All the examples that we have shown so far could be repeated using medoids as cluster prototypes instead of centroids. For example, with the K-medoids (the K-means analogue) would be:
<<>>=
wetland.kmdd = vegclust(x = wetlandchord, mobileCenters=3, 
                      method="KMdd", nstart=20)
t(wetland.kmdd$memb)
@
When ran using a site-by-species matrix as input, \texttt{vegclust} returns the coordinates of medoids as the cluster centers:
<<>>=
round(wetland.kmdd$mobileCenters, dig=3)
@
However, when using site-by-site dissimilarity matrices as input for \texttt{vegclustdist}, the indices of objects are returned instead:
<<>>=
wetland.kmdd = vegclustdist(x = dchord, mobileMemb=3, 
                      method="KMdd", nstart=20)
wetland.kmdd$mobileCenters
@

\subsection{Supervised classification: \texttt{as.vegclust} and \texttt{vegclass}}
Vegetation types are meant to be used. For example, a new area may be surveyed and a map of vegetation types may be needed. Here we simulate the process of assigning new observations to a vegetation classification created \emph{a priori}. In order to simulate this two-step process, we split our example data set into two matrices, one with the 31 objects whose group classification will be known \emph{a priori} and the other with the 10 objects whose classification is to be studied: 
<<>>=
wetland.31 = wetlandchord[1:31,]
wetland.31 = wetland.31[,colSums(wetland.31)>0]
dim(wetland.31)
wetland.10 = wetlandchord[-(1:31),]
wetland.10 = wetland.10[,colSums(wetland.10)>0] 
dim(wetland.10)
@
As initial classification, we simply take the two groups resulting from a K-means analysis (using function \texttt{kmeans} from the \texttt{stats} package) on the first data set:
<<>>=
groups = kmeans(wetland.31, 2)$cluster
groups
@
The idea is to know whether the ten objects of the second data set may be assigned to the vegetation types defined using the first data set. Because our initial classification was not obtained using \texttt{vegclust}, we need to transform the input classification of 31 objects into an object of class `vegclust'. This is done using function \texttt{as.vegclust}:
<<>>=
wetland.31.km = as.vegclust(wetland.31, groups)
@
Note that we did not specify the clustering model for our `vegclust' object. By default, the clustering method is K-means (KM):
<<>>=
wetland.31.km$method
@
In this case, this matches the way we obtained our initial classification. In general, however, we may have a classification obtained following an informal (or unknown) procedure, and we will choose the clustering model according to our preferences for assignments. Once we have our object `vegclust' we can use function \texttt{vegclass} to \emph{assign} the second set of observations according to the membership rule of the k-means cluster model:
<<>>=
wetland.10.km = vegclass(wetland.31.km, wetland.10)
defuzzify(wetland.10.km)$cluster
@
Note that all the objects of the second set were assigned to the nearest cluster. What if we want to detect which objects should better form a new vegetation type? In that is case, we may do better by using noise clustering. We can choose for example the hard noise clustering (HNC) model:
<<>>=
wetland.31.nc = as.vegclust(wetland.31, groups, method="HNC", 
                            dnoise = 0.8)
wetland.10.nc = vegclass(wetland.31.nc, wetland.10)
defuzzify(wetland.10.nc)$cluster
@
An additional parameter is needed: the distance to the noise class `dnoise', $\delta$. This can be set either conventionally (depending on the level of abstraction of vegetation types) or relying on the variance of the original clusters. The results of the noise clustering model show that several of the ten objects are assigned to the noise class (`N'), which indicates that some of them could be used to define a new cluster. 

\subsection{Extending vegetation classifications}
Vegetation classifications are dynamic entities, in the sense that they may be modified or extended as new surveys are conducted (or in general, when new data becomes available) \citep{DeCaceres2010a, Wiser2012}. The idea here is to preserve the two prototypes of the initial classification and let \texttt{vegclust} to define a new vegetation type. We first calculate the centroids of the initial classification in the resemblance space of all species (although we use object \texttt{wetlandchord},  one will normally use function \texttt{conformveg} to merge the resemblance space of two data sets):
<<>>=
fixed = clustcentroid(wetlandchord[1:length(groups),], groups)
@
And now we are ready to call \texttt{vegclust}:
<<>>=
wetland.nc = vegclust(wetlandchord, mobileCenters=1, 
                      fixedCenters = fixed, 
                      method = wetland.31.nc$method,
                      dnoise=wetland.31.nc$dnoise, nstart=10)
defuzzify(wetland.nc)$cluster
@
Here, function \texttt{vegclust} has renamed the original clusters as `F2' and `F3', while the new one is named `M1'. Note that some of the objects in the first data set may have been reassigned differently (to a different cluster or to the Noise class). While the centroids of the original classification are preserved, the membership of particular objects may change because the clustering model is not the original one. If the new memberships were strikingly different, one could decide to start the three group classification from scratch.

Instead of relying on the Noise clustering model, we could have chosen to use the K-means model to extend the classification:
<<>>=
wetland.km = vegclust(wetlandchord, mobileCenters=1, 
                      fixedCenters = fixed, 
                      method = "KM",
                      nstart=10)
defuzzify(wetland.km)$cluster
@
This avoids having objects in the Noise class. However, note that the noise clustering model allows objects in the Noise to be classified later on when new data becomes available, instead of forcing them to belong to one cluster or the other (i.e. the partition restriction).

\section{Cluster characterization}
In this section we show how to use a set of auxiliary functions that allow extracting cluster properties from an input classification. In all examples we will use this \emph{a priori} classification of our data set:
<<>>=
groups = c(rep(1, 17), rep(2, 14), rep(3,10))
@

\subsection{Cluster prototypes: \texttt{clustcentroid} and \texttt{clustmedoid}}
Functions \texttt{clustcentroid} and \texttt{clustmedoid} allow calculating the cluster centers (i.e. prototypes) corresponding to an input classification structure, which can be specified using either a cluster vector or a membership matrix. 

For example, with \texttt{clustcentroid} we can calculate the coordinates of the centroids of the initial groups using eq.~\ref{eq:centroid}:
<<>>=
centroids = clustcentroid(wetlandchord, groups)
round(centroids, dig=3)
@ 

As medoids are prototypes that are chosen among the objects to be classified, function \texttt{clustmedoid} does not return coordinates but the indices of objects. The following code uses eq.~\ref{eq:medoid} to determine the medoids of each cluster:
<<>>=
medoids = clustmedoid(wetlandchord, groups)
medoids
@ 
The value returned by function \texttt{medoid} is a vector of indices with the corresponding object names (which are numbers in this particular case). If the classification structure is a fuzzy membership matrix, the cluster centroids or medoids are determined using eqs.~\ref{eq:centroidfuzzy} and~\ref{eq:medoidfuzzy}, respectively.


\subsection{Cluster internal variability: \texttt{clustvar}}
Vegetation types may differ in the amount of variability. Function \texttt{clustvar} allows determining the amount of compositional variation (i.e. beta diversity) observed among the sites of sites belonging to each cluster in a classification structure. For clusters whose prototype is a centroid, this is calculated as the mean of squared distances from each object of the group to the group centroid. For example, the variability for a given group $i$ would be:
\begin{equation}\label{eq:clustvarcent}
Var(i) = \sum_{j=1}^{n_k}{e_{ij}^2}/n_i
\end{equation}
Note that division is by $n_i$ and not by $(n_i-1)$, which would give an unbiased sample estimate. Thus, the variances calculated in \texttt{clustvar} are population variances. For example, the variances of the three groups in our examples are:
<<>>=
clustvar(wetlandchord, groups)
@ 
The reason why population values are produced, instead of sample estimates, is because it allows calculating the variance using fuzzy membership values as:
\begin{equation}\label{eq:clustvarcentfuzzy}
Var(i) = \frac{\sum_{j=1}^{n}u_{ij}^me_{ij}^2}{\sum_{j=1}^n{u_{ij}^m}}
\end{equation}

Cluster variances can also be obtained using distance or dissimilarity matrices. In this case, the variance for a given group is calculated as:
\begin{equation}\label{eq:clustvardist}
Var(i) = \frac{1}{n_i^2} \sum_{k=1}^{n_i}\sum_{l=1}^{n_i}{d_{kl}^2}
\end{equation}
Again, division by $n_i(n_i-1)$ instead of $n_i^2$ would give an unbiased variance estimate. Because in our example the community data had been transformed using the chord transformation, the same variance values can be obtained using a distance matrix with chord distances:
<<>>=
clustvar(dchord, groups)
@ 
Finally, if no classification structure is provided function \texttt{clustvar} will return the overall variance (beta diversity) of the data table:
<<>>=
clustvar(wetlandchord)
@

\subsection{Distance between clusters: \texttt{interclustdist}}
Calculating distance between pairs of cluster prototypes is useful to determine which vegetation types are more similar and which are more distinct.When prototypes of vegetation types are chosen to be cluster medoids, then the resemblance between vegetation types can be defined as the resemblance between the corresponding medoids: 
<<>>=
as.dist(as.matrix(dchord)[medoids,medoids])
@

In contrast, if prototypes of vegetation types are chosen to be cluster centroids, the distance between two vegetation types should be defined as the distance between the cluster centroids. Following our example, we can simply use function \texttt{dist} on the matrix of centroid coordinates:
<<>>=
dist(centroids)
@ 
Alternatively, function \texttt{interclustdist} allows calculating the distance between pairs of centroids without having the coordinates of centroids themselves. Instead, the matrix of distances between objects is used. For example, if the distance between the centroids of groups $i$ and $j$ is desired, we can calculate the squared distance by:
\begin{equation}\label{eq:interclustdist}
d^2(i,j)=\frac{\sum_{k=1}^{n}\sum_{l=1}^{n}{u_{ik}^mu_{jl}^m{d_{kl}}^2}}{\sum_{k=1}^n{u_{ik}^m}\sum_{l=1}^n{u_{jl}^m}} - Var(i) - Var(j)
\end{equation}
Using equation~\ref{eq:interclustdist} in our example would be:
<<>>=
interclustdist(dchord,groups)
@ 

\subsection{Constancy classes: \texttt{clustconst}}
One way of characterizing a vegetation type is by examining the how frequently each species occurs in  vegetation observations belonging to the type. This frequency is often called \emph{constancy} and the table that contains the constancy of all species in all vegetation types is called \emph{constancy table}. Function \texttt{clustconst} allows calculating this table:
<<>>=
c = clustconst(wetlandchord, memb = as.memb(groups))
@

The R object returned by \texttt{clustconst} can be examined in several ways. First, it is useful to print the constancy table ordering species from high to low constancy for each cluster:
<<>>=
d=summary(c, mode="all")
@

Alternatively, we can examine the constancy vector of each vegetation type:
<<>>=
summary(c, mode="cluster", name=names(c)[1])
@
\bibliographystyle{plainnat}
\bibliography{vegclust}
\end{document}
